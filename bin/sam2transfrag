#!/usr/bin/perl
use strict;
use Getopt::Long;

my $usage = <<USAGE;
Usage:
    perl $0 --intron_info_out intron_info.txt scaffold_1.10000-15000.sam > scaffold_1.10000-15000.gtf

    程序能分析HISAT2比对得到的SAM文件，得到每个reads匹配区域覆盖度最高的转录本序列，以GTF文件格式为其结果文件。推荐进行HISAT2分析的时候，其允许的最大intron长度要设置得小些，比如1000bp。
    本程序输入split_sam_from_non_aligned_region.pl的结果文件，从而实现并行化运行。
    此外，本程序能同时支持链特异性测序或非连特异性测序的HISAT2比对结果。推荐使用链特异性测序数据进行Hisat2分析后，再使用本程序进行转录本搜索。
    程序分两步走：（1）首先，程序根据碱基和intron的测序深度来对有基因表达的区域进行打断，打断后的每个区域相当于一个基因表达区域；（2）然后，对各个区域进行转录本序列搜索，输出覆盖度最高的转录本序列。

    --fraction <FLOAT>  default: 0.05
        对下面两类参数expressed_base_depth和junction_depth取阈值的时候，其阈值与SAM文件比对区域的最高碱基测序深度Dmax相关。Dmax乘以该系数得到阈值D。D值和下面4个参数一起决定参数expressed_base_depth和junction_depth的设定。

    --min_expressed_base_depth <INT>  default: 2
    --max_expressed_base_depth <INT>  default: 10
        这两个参数和--fraction参数一起决定expressed_base_depth的阈值。对SAM文件中的连续比对区域区进行打断的时候，若位点的碱基测序深度低于expressed_base_depth阈值，则在该位点前后对比对区域进行打断。默认设置表示：对某个比对区域进行分析的时候，根据SAM文件计算出该区域的最高单碱基测序深度Dmax；D=Dmax * 0.05；若D小于2，则expressed_base_depth阈值=2；若D值大于10，则expressed_base_depth阈值=10；若D值在2和10之间，则expressed_base_depth阈值=D。

    --min_junction_depth <INT>  default:2
    --max_junction_depth <INT>  default:10
        这两个参数和--fraction参数一起决定junction_depth的阈值。对SAM文件中的不连续比对位点进行打断的时候，若位点的碱基测深度低于junction_depth的阈值，则在该位点前对比对区域进行打断。默认设置表示：对某个比对区域进行分析的时候，根据SAM文件计算出该区域的最高单碱基测序深度Dmax；；D=Dmax * 0.05；若D小于取2，则junction_depth=2；若D值大于10，则junction_depth=10；若D值在2和10之间，则junction_depth=D。

    --min_fragment_count_per_transfrags <INT>  default: 10
        输出transfrags信息的时候，必须要求transfrags被支持的fragment数目大于该值。
    
    --intron_info_out <String>
        若设定此参数，则会输出intron信息到指定的文件中，否则不会输出intron信息。虽然程序仅输出覆盖度最高的转录本，但是输出的intron信息是包含可变剪接信息的。且intron是经过一定阈值过滤后的结果。该文件有利于后续可变剪接分析。

    --base_depth_out <String>
        若设定此参数，则会输出所有碱基的测序深度信息到指定的文件中。该文件有利于后续可变剪接分析。

    --genome_fasta <String>
        输入基因组序列Fasta文件。若输入的SAM文件不是使用Hisat2得到的时候，其剪接性比对结果的剪接位点可能不是常规的GT-AG,GC-AG或AT-AC，因此，需要删除不属于常规剪接位点的intron信息。例如，当SAM文件是由PacBio数据得到的，由于PacBio数据有较多的Indel错误，极易导致错误的剪接位点，这时需要加上该参数。而Hisat2比对结果的剪接位点符合常规，不建议加上此参数（特别是当Hisat2数据库中添加有SNP/INDEL信息时，其比对结果可能在参考基因组序列上不符和常规剪接位点，但实际上是符合的）。
        程序会调用samtools faidx命令来得到donor和acceptor信息。因此需要安装有samtools，加入此参数的时候，程序才能正常运行。

    --min_intron_length <INT>
        设置所允许的最小intron长度。若设置了此参数，则会根据此参数对intron进行过滤。若使用Hisat2的结果进行分析，由于Hisat2是有相应的参数的（默认20），可以不用在此设置此参数。

    --gff3
        程序默认输出结果为GTF文件，若加入此参数，则输出gff3结果。
    
    --no_strand_specific
        程序默认是对链特异性测序的数据进行分析，要求输入的SAM文件中每行的比对信息都必须包含XS标签信息。若是非链特异性测序，则需要加入此参数来保证程序的正常运行，同时要求输入的SAM文件中有剪接性比对的Reds必须含有XS标签信息。相比于链特异性测序，分析非连特异性测序数据时，程序在两条链上分别进行转录本序列搜索后，排除掉有Intron的转录本区域后，再对剩下的比对区域进行单exon的转录本搜索。

    --no_PE_sequencing
        程序默认是对双末端测序数据进行分析（为了结果更加准确），若SAM文件第七列不是=符号(表示双端数据比对到不同的染色体上)时，则忽略该比对结果。若是单端测序数据，则要加入此参数，表示不会对SAM文件第七列进行检查。


USAGE
if (@ARGV==0){die $usage}

my ($fraction, $min_expressed_base_depth, $max_expressed_base_depth, $min_junction_depth, $max_junction_depth, $min_fragment_count_per_transfrags, $filter_transcript, $gff3, $intron_info_out, $base_depth_out, $genome_fasta, $min_intron_length, $no_strand_specific, $no_PE_sequencing);
GetOptions(
    "fraction:s" => \$fraction,
    "min_expressed_base_depth:s" => \$min_expressed_base_depth,
    "max_expressed_base_depth:s" => \$max_expressed_base_depth,
    "min_junction_depth:s" => \$min_junction_depth,
    "max_junction_depth:s" => \$max_junction_depth,
    "min_fragment_count_per_transfrags:s" => \$min_fragment_count_per_transfrags,
    "filter_transcript:s" => \$filter_transcript,
    "intron_info_out:s" => \$intron_info_out,
    "base_depth_out:s" => \$base_depth_out,
    "genome_fasta:s" => \$genome_fasta,
    "min_intron_length:i" => \$min_intron_length,
    "gff3!" => \$gff3,
    "no_strand_specific!" => \$no_strand_specific,
    "no_PE_sequencing!" => \$no_PE_sequencing,
);

$fraction ||= 0.05;
$min_expressed_base_depth ||= 2;
$max_expressed_base_depth ||= 10;
$min_junction_depth ||= 2;
$max_junction_depth ||= 10;
$min_fragment_count_per_transfrags ||= 10;
$filter_transcript ||= "0.25 150";

my ($filter_transcript_1, $filter_transcript_2);
if ($filter_transcript =~ m/(\S+)\s+(\d+)/) {
   ($filter_transcript_1, $filter_transcript_2) = ($1, $2);
}
else {
    die "The value of --filter_transcript should not be '$filter_transcript'! \n";
}

if ($intron_info_out) {
    open INTRON_OUT, ">", $intron_info_out or die "Can not create file $intron_info_out, $!";
    print INTRON_OUT "#Transcript_region\tChromosome\tStrand\tIntron_start\tIntron_end\tIntron_depth\tMedian_base_depth_in_intron\n";
}
if ($base_depth_out) {
    open BASE_DEPTH_OUT, ">", $base_depth_out or die "Can not create file $base_depth_out, $!";
    print BASE_DEPTH_OUT "#Chromosome\tStrand\tPosition\tDepth\n";
}

# 根据SAM文件第6列信息找intron位点和每个碱基位点的测序深度：
# M 表示match或mismatch。计算intron起始位点的时候需要加上该值；计算碱基测序深度时+1。
# I 表示read中多出额外的碱基，计算intron起始位点的时候需要略过该值。
# D 表示read中缺少相应的碱基，计算intron起始位点的时候需要加上该值；计算碱基测序深度时+1。
# S 表示soft-clipping的碱基数目，由于比对的起始位点（sam文件第4列）是去除了soft-clipping的第一个匹配碱基位点，因此计算intron起始位点的时候需要略过该值。
# 以下计算intron的起始与终止位点信息。
my (%intron, %depth, %reads);
# 将intron信息存放在%intron中；将每个位点的测序深度信息放%depth中；将reads的比对区域信息放%reads中且每1000bp一个索引，以利于后期检测某个区域中reads的count数目。
open IN, $ARGV[0] or die $!;
while (<IN>) {
    next if m/^\@/;
    @_ = split /\t/;
    my $strand = '.'; # Non Strand Specificity
    if (m/XS:A:([+-])/) {
        $strand = $1;
    }
    else {
        if (! $no_strand_specific) {
            die "Read $_[0] 的比对信息中没有XS标签信息，您的RNA-Seq数据可能是非链特异性测序，请设置--no_strand_specific参数后再运行本程序!\n";
        }
    }
    my ($read_name, $scaffold_id, $site, $cigar) = ($_[0], $_[2], $_[3], $_[5]);
    if (! $no_PE_sequencing) {
        next if $_[6] ne '=';
    }

    my @cigar = $cigar =~ m/(\d+\w)/g;
    my $start_site = $site;
    foreach (@cigar) {
        m/(\d+)(\w)/;

        if ($2 eq "M") {
            my $start = $site;
            $site += $1;
            if ($no_strand_specific) {
                foreach ($start..($site-1)) { $depth{$scaffold_id}{"+"}{$_} ++; }
                foreach ($start..($site-1)) { $depth{$scaffold_id}{"-"}{$_} ++; }
            }
            else {
                foreach ($start..($site-1)) { $depth{$scaffold_id}{$strand}{$_} ++; }
            }
        }
        elsif ($2 eq "D") {
            my $start = $site;
            $site += $1;
            if ($no_strand_specific) {
                foreach ($start..($site-1)) { $depth{$scaffold_id}{"+"}{$_} ++; }
                foreach ($start..($site-1)) { $depth{$scaffold_id}{"-"}{$_} ++; }
            }
            else {
                foreach ($start..($site-1)) { $depth{$scaffold_id}{$strand}{$_} ++; }
            }
        }
        elsif ($2 eq "I") {
            next;
        }
        elsif ($2 eq "S") {
            next;
        }
        elsif ($2 eq "N") {
            if ($strand eq '.') {
                #die "SAM文件中，Read $_[0] 的比对信息中没有XS标签信息，从而无法判断Intron的方向，导致无法得到转录本序列的方向，程序结束运行!\n";
            }
            my $start = $site;
            my $end = $start + $1 - 1;
            $intron{$scaffold_id}{$strand}{$start}{$end} ++ if $strand ne '.';
            $site += $1;
        }
        else {
            print STDERR "Other Cigar code: $2 at position $site .\n";
        }
        my $end_site = $site - 1;
        my $index1 = int($start_site / 1000);
        my $index2 =  int($end_site / 1000);
        $reads{$scaffold_id}{$strand}{$index1}{"$start_site\t$end_site"}{$read_name} = 1;
        $reads{$scaffold_id}{$strand}{$index2}{"$start_site\t$end_site"}{$read_name} = 1;
    }
}
close IN;
#print STDERR "Sam file read over\n";

# 若限制了最小intron长度，则对intron进行过滤
if ($min_intron_length) {
    my %old_intron = %intron;
    %intron = ();
    foreach my $scaffold_id (sort keys %old_intron) {
        foreach my $strand (sort keys %{$old_intron{$scaffold_id}}) {
            foreach my $start (sort {$a <=> $b} keys %{$old_intron{$scaffold_id}{$strand}}) {
                foreach my $end (sort {$a <=> $b} keys %{$old_intron{$scaffold_id}{$strand}{$start}}) {
                    $intron{$scaffold_id}{$strand}{$start}{$end} = $old_intron{$scaffold_id}{$strand}{$start}{$end} if ($end - $start + 1) >= $min_intron_length;
                }
            }
        }
    }
}

# 若输入基因组序列信息，则对Intron信息进行过滤
if ($genome_fasta) {
    my %old_intron = %intron;
    %intron = ();
    foreach my $scaffold_id (sort keys %old_intron) {
        foreach my $strand (sort keys %{$old_intron{$scaffold_id}}) {
            foreach my $start (sort {$a <=> $b} keys %{$old_intron{$scaffold_id}{$strand}}) {
                foreach my $end (sort {$a <=> $b} keys %{$old_intron{$scaffold_id}{$strand}{$start}}) {
                    my $start1 = $start + 1;
                    my $cmdString = "samtools faidx $genome_fasta $scaffold_id:$start-$start1";
                    my $donor = `$cmdString`;
                    $donor =~ s/>.*\n//; $donor =~ s/\n//;
                    my $end1 = $end - 1;
                    $cmdString = "samtools faidx $genome_fasta $scaffold_id:$end1-$end";
                    my $acceptor = `$cmdString`;
                    $acceptor =~ s/>.*\n//; $acceptor =~ s/\n//;
                    my $donnor_acceptor = "$donor$acceptor";
                    if ($strand eq "-") {
                        $donnor_acceptor = reverse $donnor_acceptor;
                        $donnor_acceptor =~ tr/ATCGatcg/TAGCtagc/;
                    }
                    if (($donnor_acceptor eq "GTAG") or ($donnor_acceptor eq "GCAG") or ($donnor_acceptor eq "ATAC")) {
                        $intron{$scaffold_id}{$strand}{$start}{$end} = $old_intron{$scaffold_id}{$strand}{$start}{$end};
                        ##print STDERR "$scaffold_id\t$start\t$end\t$strand\t$old_intron{$scaffold_id}{$strand}{$start}{$end}\n";
                    }
                }
            }
        }
    }
}

# 计算transfrags
my (%transfrags, %junction_threshold, %expressed_base_depth_threshold, %max_depth);
foreach my $scaffold_id (sort keys %depth) {
    my @strand = ("+", "-");
    foreach my $strand (@strand) {
        my @site;
        foreach (sort {$a <=> $b} keys %{$depth{$scaffold_id}{$strand}}) {
            push @site, $_ if $depth{$scaffold_id}{$strand}{$_} >= $min_expressed_base_depth;
            print BASE_DEPTH_OUT "$scaffold_id\t$strand\t$_\t$depth{$scaffold_id}{$strand}{$_}\n" if $base_depth_out;
        }

        my %intron_start;
        foreach my $intron_start (keys %{$intron{$scaffold_id}{$strand}}) {
            foreach my $intron_end (keys %{$intron{$scaffold_id}{$strand}{$intron_start}}) {
                if ($intron_start >= $site[0] && $intron_end <= $site[-1] && $intron{$scaffold_id}{$strand}{$intron_start}{$intron_end} >= $min_junction_depth) {
                    $intron_start{$intron_start}{$intron_end} = $intron{$scaffold_id}{$strand}{$intron_start}{$intron_end};
                    #print "Intron_info:\t$intron_start\t$intron_end\t$intron_start{$intron_start}{$intron_end}\n";
                }
            }
        }

        my %depth_targetRegion;
        foreach (@site) { $depth_targetRegion{$_} = $depth{$scaffold_id}{$strand}{$_}; }

        #print STDERR "$scaffold_id\t$strand\n";
        my %split_site = &split_aligned_region(\@site, \%intron_start, \%depth_targetRegion, $min_expressed_base_depth, $max_expressed_base_depth, $min_junction_depth, $max_junction_depth, $fraction);

        foreach (keys %split_site) {
            next unless $_;
            my @split_site = split /\t/;
            my $expressed_base_depth_threshold = $split_site{$_}{"expressed_base_depth_threshold"};
            my $junction_depth_threshold = $split_site{$_}{"junction_depth_threshold"};
            my $max_depth = $split_site{$_}{"max_depth"};
            my $split_site_num = @split_site;
            ##print STDERR "$scaffold_id\t$strand\t$split_site[0]\t$split_site[-1]\t$split_site_num\t$expressed_base_depth_threshold\t$junction_depth_threshold\t$max_depth\n";

            my $isoform = &find_isoforms(\@split_site, \%intron_start, \%depth_targetRegion, $expressed_base_depth_threshold, $junction_depth_threshold);
            ##print STDERR "$scaffold_id\t$strand\t$split_site[0]\t$split_site[-1]\t$split_site_num\t$expressed_base_depth_threshold\t$junction_depth_threshold\t$max_depth\t$isoform\n";
            # 若是非链特异性测序数据, 则让single exon transfrag的strand变成点号
            my $strand_out = $strand;
            if ($no_strand_specific) {
                $strand_out = '.' unless ($isoform =~  m/intron/);
            }
            $isoform =~ m/exon_start:(\d+).*exon_end:(\d+)/;
            #print STDERR "$scaffold_id\t$strand\t$split_site[0]\t$split_site[-1]\t$1\t$2\t$strand_out\n";
            $transfrags{$scaffold_id}{$strand_out}{"$1\t$2"} = $isoform;
            $junction_threshold{$scaffold_id}{$strand_out}{"$1\t$2"} = $junction_depth_threshold;
            $expressed_base_depth_threshold{$scaffold_id}{$strand_out}{"$1\t$2"} = $expressed_base_depth_threshold;
            $max_depth{$scaffold_id}{$strand_out}{"$1\t$2"} = $max_depth;
        }
    }
}

# 由于是分开在两条链上进行transfrag分析，若是非链特异性测序，则结果是：一条链上是由intron连接的transfrag，另外一条链上则是和该transfrag对应的exons的transfrags。需要对这些单exons的transfrag进行去除。例如：
#     =======----==========-----=============----====-----========>       正确的含有intron的transfrag
#     =======    =============  =====================     =========       在另外一条链上能找到的single exon类型transfrag
# 非链特异性测序的这些single exon类型需要过滤掉。若single exon和另外一条链上有intron的transcfrag的exons有重叠，就去除掉。
if ($no_strand_specific) {
    my (%exon_start_end);
    foreach my $scaffold_id (sort {$a cmp $b} keys %transfrags) {
        foreach my $strand (sort {$a cmp $b} keys %{$transfrags{$scaffold_id}}) {
            foreach my $region (sort {$a <=> $b} keys %{$transfrags{$scaffold_id}{$strand}}) {
                my $path = $transfrags{$scaffold_id}{$strand}{$region};
                my @feature = split /;/, $path;
                foreach (@feature) {
                    if (m/exon_start:(\d+),exon_end:(\d+)/ && $strand ne '.') {
                        $exon_start_end{"$1\t$2"} = 1;
                    }
                }
            }
        }
    }
    foreach my $scaffold_id (sort {$a cmp $b} keys %transfrags) {
        foreach my $region (sort {$a <=> $b} keys %{$transfrags{$scaffold_id}{'.'}}) {
            my $path = $transfrags{$scaffold_id}{'.'}{$region};
            $path =~ m/exon_start:(\d+),exon_end:(\d+)/;
            my ($start, $end) = ($1, $2);
            my $keep = 1;
            foreach (keys %exon_start_end) {
                @_ = split /\t/;
                if ($_[0] <= $end && $_[1] >= $start) {
                    $keep = 0;
                    last;
                }
            }
            delete $transfrags{$scaffold_id}{'.'}{$region} if $keep == 0;
        }
    }
}


# 所有transfrag进行使用fragment count阈值进行过滤，将结果输出到GTF/GFF3格式
foreach my $scaffold_id (sort {$a cmp $b} keys %transfrags) {
    foreach my $strand (sort {$a cmp $b} keys %{$transfrags{$scaffold_id}}) {
        foreach my $region (sort {$a <=> $b} keys %{$transfrags{$scaffold_id}{$strand}}) {
            my @region = split /\t/, $region;
            my %fragment;
            my $index1 = int($region[0] / 1000);
            my $index2 = int($region[1] / 1000);
            foreach my $index ($index1 .. $index2) {
                foreach my $read_align_region (keys %{$reads{$scaffold_id}{$strand}{$index}}) {
                    @_ = split /\t/, $read_align_region;
                    if ($_[1] >= $region[0] && $_[0] <= $region[1]) {
                        foreach (keys %{$reads{$scaffold_id}{$strand}{$index}{$read_align_region}}) {
                            $fragment{$_} = 1;
                        }
                    }
                }
            }
            #若是非链特异性测序，则计算fragment count的时候，则不能考虑read的比对方向。
            if ($no_strand_specific) {
                %fragment = ();
                foreach my $strand1 (keys  %{$reads{$scaffold_id}}) {
                    foreach my $index ($index1 .. $index2) {
                        foreach my $read_align_region (keys %{$reads{$scaffold_id}{$strand1}{$index}}) {
                            @_ = split /\t/, $read_align_region;
                            if ($_[1] >= $region[0] && $_[0] <= $region[1]) {
                                foreach (keys %{$reads{$scaffold_id}{$strand1}{$index}{$read_align_region}}) {
                                    $fragment{$_} = 1;
                                }
                            }
                        }
                    }
                }
            }
            my $fragment = keys %fragment;
            #print STDERR "$scaffold_id\t$strand\t$region\t$fragment\n";

            if ($fragment >= $min_fragment_count_per_transfrags) {
                my $strand_name;
                if ($strand eq "+") { $strand_name = "plus"; }
                elsif ($strand eq "-") { $strand_name = "minus"; }
                elsif ($strand eq ".") { $strand_name = "noStrandInfo"; }

                # 输出 intron 信息
                if ($intron_info_out) {
                    foreach my $intron_start (sort {$a <=> $b} keys %{$intron{$scaffold_id}{$strand}}) {
                        foreach my $intron_end (sort {$a <=> $b} keys %{$intron{$scaffold_id}{$strand}{$intron_start}}) {
                            if ($intron_start >= $region[0] && $intron_end <= $region[-1] && $intron{$scaffold_id}{$strand}{$intron_start}{$intron_end} >= $junction_threshold{$scaffold_id}{$strand}{$region}) {
                                my @base_depth_in_intron;
                                foreach ($intron_start .. $intron_end) {
                                    my $base_depth_in_intron_of_one_base = 0;
                                    $base_depth_in_intron_of_one_base = $depth{$scaffold_id}{$strand}{$_} if $depth{$scaffold_id}{$strand}{$_};
                                    push @base_depth_in_intron, $base_depth_in_intron_of_one_base;
                                }
                                @base_depth_in_intron = sort {$a <=> $b} @base_depth_in_intron;
                                my $median_base_depth_in_intron = $base_depth_in_intron[@base_depth_in_intron/2];
                                print INTRON_OUT "$scaffold_id\_$strand_name\_$region[0]\_$region[1]\t$scaffold_id\t$strand\t$intron_start\t$intron_end\t$intron{$scaffold_id}{$strand}{$intron_start}{$intron_end}\t$median_base_depth_in_intron\n";
                            }
                        }
                    }
                }

                my ($gff3_out, $gtf_out, $mRNA_number);

                my $path = $transfrags{$scaffold_id}{$strand}{$region};
                #print STDERR "$scaffold_id\t$strand\t$region\n$path\n";
                my @feature = split /;/, $path;
                my %mRNA_start_end;
                $mRNA_number ++;
                my ($feature_out_gff3, $feature_out_gtf);
                my ($exon_number, $intron_number);
                @feature = reverse @feature if $strand eq "-";
                my ($last_end, $last_start);
                my $feature_number = 0;
                foreach (@feature) {
                    $feature_number ++;
                    if (m/(\w+)_start:(\d+),\1\_end:(\d+)/) {
                        $mRNA_start_end{$2} = 1;
                        $mRNA_start_end{$3} = 1;
                        print STDERR "Warning: discontinuous\t$ARGV[0]\t$scaffold_id\t$strand\t$region\t$_\n$path\n" if ( (! (($2 == $last_end + 1) or ($3 == $last_start - 1))) && $feature_number > 1 );
                        $last_end = $3; $last_start = $2;
                        if ($1 eq "intron") {
                            my $intron_supported_reads_number = $intron{$scaffold_id}{$strand}{$2}{$3};
                            $feature_out_gff3 .= "$scaffold_id\tChenLianfu\tintron\t$2\t$3\t$intron_supported_reads_number\t$strand\t\.\tID=$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number.intron$intron_number;Parent=$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number;\n";
                            $feature_out_gtf .= "$scaffold_id\tChenLianfu\tintron\t$2\t$3\t$intron_supported_reads_number\t$strand\t\.\tgene_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1]\"; transcript_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number\";\n";
                        }
                        elsif ($1 eq "exon") {
                            $exon_number ++;
                            $feature_out_gff3 .= "$scaffold_id\tChenLianfu\texon\t$2\t$3\t\.\t$strand\t\.\tID=$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number.exon$exon_number;Parent=$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number;\n";
                            $feature_out_gtf .= "$scaffold_id\tChenLianfu\texon\t$2\t$3\t\.\t$strand\t\.\tgene_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1]\"; transcript_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number\";\n";
                        }
                        else {
                            print STDERR "Warning: $ARGV[0]\t$scaffold_id\t$strand\t$region\t$_\n";
                        }
                    }
                    else {
                        print STDERR "Warning: $ARGV[0]\t$scaffold_id\t$strand\t$region\t$_\n";
                    }
                }
                my @mRNA_start_end = sort {$a <=> $b} keys %mRNA_start_end;
                $gff3_out .= "$scaffold_id\tChenLianfu\tmRNA\t$mRNA_start_end[0]\t$mRNA_start_end[-1]\t\.\t$strand\t\.\tID=$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number;Parent=$scaffold_id\_$strand_name\_$region[0]\_$region[1];\n$feature_out_gff3" if $feature_out_gff3;
                $gtf_out .= "$scaffold_id\tChenLianfu\ttranscript\t$mRNA_start_end[0]\t$mRNA_start_end[-1]\t\.\t$strand\t\.\tgene_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1]\"; transcript_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1].mRNA$mRNA_number\";\n$feature_out_gtf" if $feature_out_gtf;

                if ($gff3 && $gff3_out) {
                    print "$scaffold_id\tChenLianfu\tgene\t$region\t\.\t$strand\t\.\tID=$scaffold_id\_$strand_name\_$region[0]\_$region[1]; FragmentCount=$fragment; JunctionThreshold=$junction_threshold{$scaffold_id}{$strand}{$region}; BaseDepthThreshold=$expressed_base_depth_threshold{$scaffold_id}{$strand}{$region}; MaxDepth=$max_depth{$scaffold_id}{$strand}{$region};\n$gff3_out\n";
                }
                elsif ($gtf_out) {
                    print "$scaffold_id\tChenLianfu\tgene\t$region\t\.\t$strand\t\.\tgene_id \"$scaffold_id\_$strand_name\_$region[0]\_$region[1]\"; FragmentCount \"$fragment\"; JunctionThreshold \"$junction_threshold{$scaffold_id}{$strand}{$region}\"; BaseDepthThreshold \"$expressed_base_depth_threshold{$scaffold_id}{$strand}{$region}\"; MaxDepth \"$max_depth{$scaffold_id}{$strand}{$region}\";\n$gtf_out\n";
                }
            }
        }
    }
}

close INTRON_OUT;
close BASE_DEPTH_OUT;

# 子程序 find_isoforms 用于寻找指定区域的 transfrags
sub find_isoforms {
    my @site_raw = @{$_[0]};
    my %intron_start_raw = %{$_[1]};
    my %depth_raw = %{$_[2]};
    my $expressed_base_depth_threshold = $_[3];
    my $junction_depth_threshold = $_[4];

    my (@site, %siteee, %depth);
    foreach (@site_raw) {
        #print STDERR "$_\t$depth_raw{$_}\n";
        if ($depth_raw{$_} >= $expressed_base_depth_threshold) {
            push @site, $_;
            $siteee{$_} = 1;
            $depth{$_} = $depth_raw{$_};
        }
    }

    my (%intron_start, %intron_region_for_filter1, %intron_region_for_filter2);
    # 根据junction_depth_threshold过滤introns
    foreach my $intron_start (sort {$a <=> $b}  keys %intron_start_raw) {
        foreach my $intron_end(sort {$a <=> $b} keys %{$intron_start_raw{$intron_start}}) {
            if ($intron_start > $site[0] && $intron_end < $site[-1] && $intron_start_raw{$intron_start}{$intron_end} >= $junction_depth_threshold) {
                $intron_start{$intron_start}{$intron_end} = $intron_start_raw{$intron_start}{$intron_end};
                $intron_region_for_filter1{"$intron_start\t$intron_end"} = $intron_start;
                $intron_region_for_filter2{"$intron_start\t$intron_end"} = $intron_end;
            }
        }
    }
    # 若两个intron有重叠，则过滤掉depth较低的那个intron。注意，若一个intron和其它多个introns有重叠，该intron的depth必须高于所有其它多个introns的depth，才能保留。
    while (%intron_region_for_filter1) {
        my @start_end = sort {$intron_region_for_filter1{$a} <=> $intron_region_for_filter1{$b} or $intron_region_for_filter2{$b} <=> $intron_region_for_filter2{$a}} keys %intron_region_for_filter1;
        my $first = shift @start_end;
        $first =~ m/(\d+)\t(\d+)/;
        my ($intron_start, $intron_end) = ($1, $2);
        my $keep = 1;
        delete $intron_region_for_filter1{$first};
        delete $intron_region_for_filter2{$first};

        foreach (@start_end) {
            @_ = split /\t/;
            # + 1 或 -1 是为了防止两个相邻的introns出现，例如 224501-226456 和 226457-228411 这样两个introns出现就会导致问题。
            if ($intron_start <= ($_[1] + 1) && $intron_end >= ($_[0] - 1) && $intron_start{$intron_start}{$intron_end} < $intron_start{$_[0]}{$_[1]}) {
                $keep = 0;
                last;
            }
        }

        if ($keep == 1) {
            foreach (@start_end) {
                @_ = split /\t/;
                if ($intron_start <= ($_[1] + 1) && $intron_end >= ($_[0] - 1)) {
                    delete $intron_start{$_[0]}{$_[1]};
                    delete $intron_region_for_filter1{"$_[0]\t$_[1]"};
                    delete $intron_region_for_filter2{"$_[0]\t$_[1]"};
                }
            }
        }
        else {
            delete $intron_start{$intron_start}{$intron_end};
        }
    }

    # 若intron区域有内含子保留，若intron depth < base depth median，则过滤该intron，否则删除该intron区域内所有位点的碱基深度信息。
    foreach my $intron_start (sort {$a <=> $b} keys %intron_start) {
        foreach my $intron_end(sort {$a <=> $b} keys %{$intron_start{$intron_start}}) {
            my $intron_depth = $intron_start{$intron_start}{$intron_end};
            my $intron_keep = 0;
            my @site_depth;
            foreach ($intron_start .. $intron_end) {
                if (! exists $siteee{$_}) {
                    $intron_keep = 1;
                    last;
                }
                else {
                    push @site_depth, $depth{$_};
                }
            }
            if ($intron_keep == 0) {
                @site_depth = sort {$b <=> $a} @site_depth;
                my $median_site_depth = $site_depth[@site_depth/2];
                $intron_keep = 1 if $intron_depth >= $median_site_depth;
            }
            if ($intron_keep == 0) {
                delete $intron_start{$intron_start}{$intron_end};
            }
            else {
                foreach ($intron_start .. $intron_end) {
                    delete $siteee{$_} if exists $siteee{$_};
                }
            }
        }
    }

    my %intron_end;
    foreach my $intron_start (sort keys %intron_start) {
        foreach my $intron_end(sort keys %{$intron_start{$intron_start}}) {
            $intron_start{$intron_start}{$intron_end} = $intron_start{$intron_start}{$intron_end};
            $intron_end{$intron_end} = $intron_start;
            #print STDERR "find_sioforms,IntroInfo:\t$intron_start\t$intron_end\t$intron_start{$intron_start}{$intron_end}\n";
        }
    }

    my (@site, %depth);
    foreach (sort {$a <=> $b} sort %siteee) {
        if ($depth_raw{$_} >= $expressed_base_depth_threshold) {
            push @site, $_;
            $depth{$_} = $depth_raw{$_};
        }
    }

    my $last_site = $site[0] - 1;
    my $path="exon_start:$site[0],";
    my $num = 0;
    foreach my $site (@site) {
        $num ++;
        #print STDERR "$site\t$last_site\t$depth{$site}\t$site[0]\t$site[-1]\n";
        if (exists $intron_end{$site - 1}) {
            my $intron_end = $site - 1;
            $path .= "exon_end:$last_site;intron_start:$intron_end{$intron_end},intron_end:$intron_end;exon_start:$site,";
        }
        elsif ($site != $last_site + 1) {
            # 若某个较长的intron支持的基因区域，在进行最高覆盖度transfrag计算时，该intron被过滤掉了，若该intron区域对应的部分碱基位点测序深度较低，就会出现此种情况。出现较长的intron可能出现此种情况，2个方向一致的基因太近了也会出现此种情况。
            #warn "Warning: $ARGV[0]\t $site position without a intron end before\n";
        }
        $last_site = $site;

        if ($num == @site) {
            $path .= "exon_end:$site";
        }
    }

    return $path;
}


# 子程序 split_aligned_region 用于将SAM的比对区域进行分割。测序深度较高的区域设置较高的阈值（碱基测序深度和intron测序深度）。
sub split_aligned_region {
    my @site = @{$_[0]};
    my %intron_start = %{$_[1]};
    my %depth = %{$_[2]};
    my $min_expressed_base_depth = $_[3];
    my $max_expressed_base_depth = $_[4];
    my $min_junction_depth = $_[5];
    my $max_junction_depth = $_[6];
    my $fraction = $_[7];
    
    #foreach (@site) { print "$_\n"; }
    #foreach (sort {$a <=> $b} keys %depth) { print STDERR "$_\t$depth{$_}\n"; }
    #print STDERR "$min_expressed_base_depth\t$max_expressed_base_depth\t$min_junction_depth\t$max_junction_depth\n";

    # 首先，使用最低阈值（碱基测序深度和intron测序深度）在给定的比对区域中找打断位点（将打断位点数据保存在 %split_position 中，在数据表示的位点前进行打断，即表示该位点属于下一个比对区域）。
    my %split_position;

    my %intron_depth_all;
    foreach my $intron_start (sort {$a <=> $b} keys %intron_start) {
        foreach my $intron_end (sort {$a <=> $b} keys %{$intron_start{$intron_start}}) {
            my $intron_depth = $intron_start{$intron_start}{$intron_end};
            my $start = $intron_start - 1;
            my $end = $intron_end + 1;
            $intron_depth_all{"$start\t$end"} = $intron_depth if ($intron_depth >= $min_junction_depth && $intron_start > $site[0] && $intron_end < $site[-1]);
            ##print STDERR "Intron Depth Info:\t$start\t$end\t$intron_depth\n";
        }
    }

    my $last_site = $site[0] - 1;
    my $arrary_num = 0;
    foreach my $site (@site) {
        $arrary_num ++;
        my (@intron_depth, $depth);
        foreach (keys %intron_depth_all) {
            my ($intron_start, $intron_end) = split /\t/;
            push @intron_depth, $intron_depth_all{$_} if ($site >= $intron_start && $site <= $intron_end);
        }
        @intron_depth = sort {$b <=> $a} @intron_depth;
        my $intron_depth = 0;
        $intron_depth = $intron_depth[0] if @intron_depth;
        $depth = $depth{$site}; 
        ##print "Site:Intron_depth:Depth\t$site:$intron_depth:$depth\n";
        # 若分析的位点和上一个位点是紧挨着的
        #   若该位点和存在的下一个位点不是紧挨着的
        #     若该位点的intron_depth低于阈值，则在该位点后进行打断
        #       若该位点的base_depth低于阈值，则在该位点前后进行打断
        #   此外，
        #     若该位点的intron_depth低于阈值
        #      若该位点的base_depth低于阈值，则在该位点前后进行打断
        # 此外，若分析的位点和上一个位点不是紧挨着的
        #   若该位点和存在的下一个位点不是紧挨着的
        #     若该位点的intron_depth低于阈值，则在该位点前后进行打断
        #   此外，
        #     若该位点的intron_depth低于阈值，则在该位点前进行打断
        #       若该位点的base_depth低于阈值，则在该位点前后进行打断
        if ($site - $last_site == 1) {
            if ($site[$arrary_num] - $site > 1) {
                if ($intron_depth < $min_junction_depth) {
                    $split_position{$site[$arrary_num]} = 1;
                    if ($depth < $min_expressed_base_depth) {
                        $split_position{$site} = 1;
                    }
                }
            }
            else {
                if ($depth < $min_expressed_base_depth && $intron_depth < $min_junction_depth) {
                    $split_position{$site} = 1;
                    $split_position{$site[$arrary_num]} = 1 if $site[$arrary_num];
                }
            }
        }
        elsif ($site - $last_site > 1) {
            if ($site[$arrary_num] - $site > 1) {
                if ($intron_depth < $min_junction_depth) {
                    $split_position{$site} = 1;
                    $split_position{$site[$arrary_num]} = 1;
                }
            }
            else {
                if ($intron_depth < $min_junction_depth) {
                    $split_position{$site} = 1;
                    $split_position{$site[$arrary_num]} = 1 if ($site[$arrary_num] && ($depth < $min_expressed_base_depth));
                }
            }
        }
        $last_site = $site;
    }

    # 然后，将给定的比对区域打断后，对得到的二级比对区域使用较高的阈值(与二级比对区域的测序深度相关)再次寻找打断位点。采用的方法是多次迭代，逐个提取出最高平均碱基测序深度的比对区域。例如：对二级区域使用较高的阈值进行分析，得到多个低测序深度位点和在这些位点打断后的比对区域；找出其中平均碱基测序深度最高的比对区域；取该区域两端的两个碱基位点作为打断位点；对二级区域进行打断，得到3个三级比对区域；对三级比对区域重复上述步骤找四级比对区域，直到不能找到新的打断位点。最终，根据打断位点，得到各个比对区域。
    my $split_position_number = -1;
    my %split_region;
    while ((keys %split_position) > $split_position_number) {
        $split_position_number = keys %split_position;
        # 将 @site 根据 %split_position 信息打断成多个片段，存储到 %splite_site 中
        my (%split_site, @split_site);
        foreach (@site) {
            if (exists $split_position{$_}) {
                my $split_site = join "\t", @split_site;
                $split_site{$split_site} = 1 if @split_site >= 100;
                @split_site = ($_);
            }
            else {
                push @split_site, $_;
            }
        }
        my $split_site = join "\t", @split_site;
        $split_site{$split_site} = 1 if @split_site >= 100;

        # 对每个片段设定相应的阈值（碱基测序深度和intron测序深度）再进行打断。
        # 若在 %split_site 中存在的片段，则不进行上述分析
        # 若检测的阈值是最低阈值的时候，则使用最低阈值对相应的片段打断，并将打断后的片段都添加到 %split_site 中，将打断位点信息添加到 %split_position 中
        # 若检测的阈值不是最低阈值的时候，则使用相应的阈值对相应的片段打断，仅将打断后片段中平均碱基测序深度最大的片段添加到 %split_site 中，将此最大片段两端的打断位点添加到 %split_position 中
        foreach my $site (keys %split_site) {
            my @sites = split /\t/, $site;
            next if @sites < 100;
            if (! exists $split_region{$site}) {
                # 确定碱基测序深度和intron测序深度的阈值
                my ($max_depth, $expressed_base_depth_threshold, $junction_depth_threshold);
                foreach (@sites) {
                    $max_depth = $depth{$_} if $depth{$_} > $max_depth;
                }
                if ($max_depth * $fraction < $min_expressed_base_depth) { $expressed_base_depth_threshold = $min_expressed_base_depth; }
                elsif ($max_depth * $fraction > $max_expressed_base_depth) { $expressed_base_depth_threshold = $max_expressed_base_depth; }
                else { $expressed_base_depth_threshold = int($max_depth * $fraction + 0.5); }
                if ($max_depth * $fraction < $min_junction_depth) { $junction_depth_threshold = $min_junction_depth; }
                elsif ($max_depth * $fraction > $max_junction_depth) { $junction_depth_threshold = $max_junction_depth; }
                else { $junction_depth_threshold = int($max_depth * $fraction + 0.5); }
                ##print STDERR "Max_depth\tExpressed_base_depth_threshold\tJunction_depth_threshold\tOF $sites[0]-$sites[1]\n";
                ##print STDERR "$max_depth\t$expressed_base_depth_threshold\t$junction_depth_threshold\n";

                # 根据阈值找打断位点
                my %low_depth_position;
                my %intron_depth;
                foreach (keys %intron_depth_all) {
                    @_ = split /\t/;
                    $intron_depth{$_} = $intron_depth_all{$_} if ($_[0] >= $sites[0] && $_[1] <= $sites[-1]);
                }

                my $last_site = $sites[0] - 1;
                my $arrary_num = 0;
                foreach my $site (@sites) {
                    $arrary_num ++;
                    my (@intron_depth, $depth);
                    foreach (keys %intron_depth) {
                        my ($intron_start, $intron_end) = split /\t/;
                        push @intron_depth, $intron_depth{$_} if ($site >= $intron_start && $site <= $intron_end);
                    }
                    @intron_depth = sort {$b <=> $a} @intron_depth;
                    my $intron_depth = 0;
                    $intron_depth = $intron_depth[0] if @intron_depth;
                    $depth = $depth{$site}; 
                    if ($site - $last_site == 1) {
                        if  ($sites[$arrary_num] - $site > 1) {
                            if ($intron_depth < $junction_depth_threshold) {
                                $low_depth_position{$sites[$arrary_num]} = 1;
                                if ($depth < $expressed_base_depth_threshold) {
                                    $low_depth_position{$site} = 1;
                                }
                            }
                        }
                        else {
                            if ($depth < $expressed_base_depth_threshold && $intron_depth < $junction_depth_threshold) {
                                $low_depth_position{$site} = 1;
                                $low_depth_position{$sites[$arrary_num]} = 1 if $sites[$arrary_num];
                            }
                        }
                    }
                    elsif ($site - $last_site > 1) {
                        if ($sites[$arrary_num] - $site > 1) {
                            if ($intron_depth < $junction_depth_threshold) {
                                $low_depth_position{$site} = 1;
                                $low_depth_position{$sites[$arrary_num]} = 1;
                            }
                        }
                        else {
                            if ($intron_depth < $junction_depth_threshold) {
                                $low_depth_position{$site} = 1;
                                $low_depth_position{$sites[$arrary_num]} = 1 if ($sites[$arrary_num] && ($depth < $expressed_base_depth_threshold));
                            }
                        }
                    }
                    $last_site = $site;
                }
                ##my $low_depth_position;
                ##foreach (sort keys %low_depth_position) { $low_depth_position .= "$_\t" if $_; }
                ##print STDERR "Low Depth Position:\t$low_depth_position\n" if $low_depth_position;

                # 根据打断位点，得到打断后的片段
                my (%split_sites, @split_sites);
                foreach (@sites) {
                    if (exists $low_depth_position{$_}) {
                        my $split_sites = join "\t", @split_sites;
                        $split_sites{$split_sites} = 1 if @split_sites >= 100;
                        @split_sites = ($_);
                    }
                    else {
                        push @split_sites, $_;
                    }
                }
                my $split_sites = join "\t", @split_sites;
                $split_sites{$split_sites} = 1 if @split_sites >= 100;

                # 若检测的阈值是最低阈值的时候，将打断后的片段都添加到 %split_site 中，将打断位点信息添加到 %split_position 中
                if ($expressed_base_depth_threshold == $min_expressed_base_depth && $junction_depth_threshold == $min_junction_depth) {
                    foreach (keys %split_sites) {
                        $split_region{$_}{"expressed_base_depth_threshold"} = $expressed_base_depth_threshold;
                        $split_region{$_}{"junction_depth_threshold"} = $junction_depth_threshold;
                        $split_region{$_}{"max_depth"} = $max_depth;
                    }
                    foreach (keys %low_depth_position) {
                        $split_position{$_} = 1;
                    }
                }
                else {
                    # 得到打断后片段的平均碱基测序深度
                    my %avg_depth;
                    foreach (keys %split_sites) {
                        my @split_sites = split /\t/;
                        my ($total, $base_num);
                        foreach (@split_sites) {
                            $base_num ++;
                            $total += $depth{$_};
                        }
                        my $avg = int($total / $base_num + 0.5);
                        ##print STDER "split region depth info:\t$base_num\t$total\t$avg\n";
                        $avg_depth{$_} = $total / $base_num if @split_sites;
                    }
                    # 将平均碱基测序深度最高的片段放入 %split_site 中, 将该片段两端的两个碱基位点放入 %split_position 中
                    my @avg_depth = sort {$avg_depth{$b} <=> $avg_depth{$a}} keys %avg_depth;
                    my @split_sites = split /\t/, $avg_depth[0];
                    $split_region{$avg_depth[0]}{"expressed_base_depth_threshold"} = $expressed_base_depth_threshold;
                    $split_region{$avg_depth[0]}{"junction_depth_threshold"} = $junction_depth_threshold;
                    $split_region{$avg_depth[0]}{"max_depth"} = $max_depth;
                    $split_position{$split_sites[0]} = 1;
                    my @sites1 = @site;
                    while (@sites1) {
                        my $aaa = shift @sites1; 
                        if ($aaa == $split_sites[-1]) {
                            $aaa = shift @sites1; 
                            $split_position{$aaa} = 1;
                            last;
                        }
                    }
                }
            }
        }
    }
    return %split_region;
}
