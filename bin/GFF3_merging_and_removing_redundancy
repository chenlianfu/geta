#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $usage = <<USAGE;
Usage:
    $0 [options] genome.fasta in1.gff3 in2.gff3 in3.gff3 ... > out.gff3 

    本程序用于将输入的一个或多个GFF3文件中的基因模型，进行去冗余处理，对基因模型进行打分并挑选更可信的结果。

    程序运行原理：
    (1) 程序对所有输入的基因模型进行打分。首先，按CDS长度进行打分，每bp长度记1分，得到初步得分S；然后，根据intron数量打分，每增加一个intron，增加一定比例(相对S)得分，第一个intron增加分数最多，后续的intron增加的分数按比例递减，且所有intron增加的得分之和不超过S；然后，按基因完整性打分，5'端完整，增加一定比例(相对S)得分，3'端完整，增加一定比例(相对S)得分；最后，按输入文件的先后顺序，第一个输入文件，增加一定比例(相对S)得分，第二个输入文件分值不变。
    (2) 当两个基因模型在CDS上有重叠，对其中任意一个基因模型重叠比例超过阈值时，则根据两个基因模型的打分，去除较低得分的基因模型。程序会首先找到两两重叠的基因类群，再对类群中的基因模型按得分从大到小进行去冗余处理。

    程序使用须知：
    (1) 程序需要输入基因组序列，用于检测基因模型的完整性。
    (2) 本程序接受输入带可变剪接的GFF3文件，对一个基因的多个转录本进行打分后，选其中得分最高转录本的CDS信息的作为基因的信息，再和其它基因模型进行重叠分析和得分比较。

    --intron_score <float>    default: 0.3
    设置intron让基因模型得分提升比例。基因模型的一个intron让得分增加比例 = 该参数值；第二个及其它intron让得分增加比例 = (1 - 该参数值) ** (intron序号 - 1)。即多个intron让得分提升的比例呈一个无限等比数列，其首项 = 该参数值，公比 = (1 - 该参数值)，无限等比数列的和 = 1。默认设置下，首项 = 0.3，公比 = 0.7，即第一个intron让得分增加30%，第二个intron让得分增加21%，第三个intron让得分增加14.7%，第四个10.29%，以此类推，最终所有intron让得分增加比例不会超过100%。

    --complete5p_score <float>    default: 0.5
    设置基因模型在5'端完整时得分增加比例。

    --complete3p_score <float>    default: 0.5
    设置基因模型在3'端完整时得分增加比例。

    --first_file_score <float>    default: 0.5
    设置第一个输入文件额外增加的得分比例。有利于优先选择第一个输入GFF3文件中的基因模型。

    --overlap_coverage <float>    default: 0.30
    设置一个覆盖度阈值。当两个基因型模型对应转录本的CDS重叠区碱基数 / 较小基因模型CDS去冗余碱基数 > 该覆盖度阈值时， 则需要去除冗余的基因模型。

    --start_codon <string>    default: ATG
    设置起始密码子。若有多个起始密码子，则使用逗号分割。

    --stop_codon <string>    default: TAA,TAG,TGA
    设置终止密码子。若有多个终止密码子，则使用逗号分割。

    --help    default: None
    display this help and exit.

    --chinese_help    default: None
    使用该参数后，程序给出中文用法并退出。

USAGE
my $usage_english = &get_usage_english();
if (@ARGV==0){die $usage_english}

my ($intron_score, $complete5p_score, $complete3p_score, $first_file_score, $overlap_coverage, $start_codon, $stop_codon, $help, $chinese_help);
GetOptions(
    "intron_score:f" => \$intron_score,
    "complete5p_score:f" => \$complete5p_score,
    "complete3p_score:f" => \$complete3p_score,
    "first_file_score:f" => \$first_file_score,
    "overlap_coverage:f" => \$overlap_coverage,
    "start_codon:s" => \$start_codon,
    "stop_codon:s" => \$stop_codon,
    "help" => \$help,
    "chinese_help" => \$chinese_help,
);
if ( $chinese_help ) { die $usage }
if ( $help ) { die $usage_english }

########### 解析参数 #################
# 使用绝对路径
my $input_genome = abs_path(shift @ARGV);
my @input_GFF3;
foreach ( @ARGV ) {
    push @input_GFF3, abs_path($_);
}

# 设置参数的默认值
$intron_score = 0.3 unless defined $intron_score;
$complete5p_score = 0.5 unless defined $complete5p_score;
$complete3p_score = 0.5 unless defined $complete3p_score;
$first_file_score = 0.5 unless defined $first_file_score;
$overlap_coverage = 0.3 unless defined $overlap_coverage;
$start_codon ||= "ATG";
$stop_codon ||= "TAA,TAG,TGA";
my (%start_codon, %stop_codon);
foreach (split /,/, $start_codon) { $start_codon{$_} = 1; }
foreach (split /,/, $stop_codon) { $stop_codon{$_} = 1; }
###############################

#读取基因组序列
open IN, $input_genome or die "Error: Can not open file $input_genome, $!";
my (%seq, $seq_id);
while (<IN>) {
    chomp;
    if ( m/^>(\S+)/ ) { $seq_id = $1; }
    else { tr/atcgn/ATCGN/; $seq{$seq_id} .= $_; }
}
close IN;

# 依次分析输入的GFF3文件，得到基因信息
# %gene_CDS，存放两个文件中所有基因的CDS信息，键是基因ID，值是\n分隔的CDS信息(起始结束正负链用\t分隔)。若基因有多个可变剪接，选择其得分最高转录本的CDS信息。
# %cds2gene存放每个CDS对应的基因ID信息，是一个多重哈希。染色体名称 -> 正负链 -> 索引位置 -> CDS起始结束 -> 基因ID -> 1。用于找两两重叠的基因。
# %gene_CDS 和 %cds2gene 用于找有重叠的基因。
# %gene_score，存放基因ID的得分。
# %chr 和 %strand 存放基因ID对应的染色体和正负链。
# %gene_CDS_length 存放基因ID对应的CDS长度。若基因有多个可变剪接，选择其得分最高转录本的CDS长度。
my (%gene_CDS, %cds2gene, %gene_score, %chr, %strand, %gene_CDS_length, %sort1, %sort2, %sort3, %sort4, %gene_info);
my $input_file_num = 0;
foreach ( @input_GFF3 ) {
    $input_file_num ++;

    # 读入GFF3内容
    my %GFF3_info = &get_geneModels_from_GFF3($_);
    foreach my $gene_ID ( sort keys %GFF3_info ) {
        # 分析基因的GFF3信息，做好排序，以利于最终的数据输出
        my @gene_header = split /\t/, $GFF3_info{$gene_ID}{"header"};
        $sort1{$gene_ID} = $gene_header[0];
        $sort2{$gene_ID} = $gene_header[3];
        $sort3{$gene_ID} = $gene_header[4];
        $sort4{$gene_ID} = $gene_header[6];
        $gene_info{$gene_ID} = $GFF3_info{$gene_ID};

        my @mRNA_ID = @{$GFF3_info{$gene_ID}{"mRNA_ID"}};
        # 对每个转录本进行打分，最终每个基因选择其最高分值的转录本作为其CDS信息。
        my (%mRNA_score, %mRNA_CDS, %mRNA_CDS_length);
        foreach my $mRNA_ID ( sort @mRNA_ID ) {
            my $mRNA_info = $GFF3_info{$gene_ID}{"mRNA_info"}{$mRNA_ID};
            my $mRNA_header = $GFF3_info{$gene_ID}{"mRNA_header"}{$mRNA_ID};
            my @mRNA_header = split /\t/, $mRNA_header;
            # 获得染色体名称和正负链信息
            my ($chr, $strand) = ($mRNA_header[0], $mRNA_header[6]);
            $chr{$gene_ID} = $chr; $strand{$gene_ID} = $strand;

            # 分析转录本的CDS信息
            my (@CDS, $CDS_length);
            foreach ( split /\n/, $mRNA_info ) {
                @_ = split /\t/;
                if ( $_[2] eq "CDS" ) {
                    push @CDS, "$_[3]\t$_[4]\t$_[6]";
                    $CDS_length += (abs($_[4] - $_[3]) + 1);
                    my $index1 = int($_[3] / 1000);
                    my $index2 = int($_[4] / 1000);
                    foreach ($index1 .. $index2) {
                        $cds2gene{$chr}{$strand}{$_}{"$_[3]\t$_[4]"}{$gene_ID} = 1;
                    }
                }
            }
            $mRNA_CDS{$mRNA_ID} = join "\n", @CDS;
            $mRNA_CDS_length{$mRNA_ID} = $CDS_length;
    
            # 分析转录本的完整性
            my $integrity = &analysis_geneModels_integrity(\@CDS, $chr, $strand);
    
            # 计算转录本得分
            my $score = $CDS_length;
            #print STDERR "$mRNA_ID\t$score\n";
            # 首先根据intron数量，增加得分比例
            if ( @CDS == 1 ) {
                # 只有一个CDS，则得分就是CDS长度
                $score = $CDS_length;
            }
            elsif ( @CDS == 2 ) {
                # 有两个CDS，则得分增加--intron_score参数设定的比例
                $score += $CDS_length * $intron_score;
            }
            elsif ( @CDS > 2 ) {
                # 有三个或以上CDS，第一个intron增加--intron_score参数设定的比例
                my $add_score = $CDS_length * $intron_score;
                $score += $add_score;
                # 从第二个intron及往后，增加的分值逐项递减。为上一个intron的 ( 1 - intron_score参数值)。
                foreach ( 1 .. (@CDS - 2) ) {
                    $add_score = $add_score * ( 1 - $intron_score );
                    $score += $add_score;
                }
            }
            #print STDERR "$mRNA_ID\t$score\n";
            # 再根据基因完整性进行打分
            if ( $integrity eq "5prime_partial" ) {
                $score += $CDS_length * $complete3p_score;
            }
            elsif ( $integrity eq "3prime_partial" ) {
                $score += $CDS_length * $complete5p_score;
            }
            elsif ( $integrity eq "complete" ) {
                $score += $CDS_length * ($complete3p_score + $complete5p_score);
            }
            #print STDERR "$mRNA_ID\t$score\n";
            # 若使输入的第一个GFF3文件，则继续增加得分
            $score += $CDS_length * $first_file_score if $input_file_num == 1; 
            #print STDERR "$mRNA_ID\t$score\n";
    
            $mRNA_score{$mRNA_ID} = $score;
    
            #print STDERR "$mRNA_ID\t$integrity\t$score\n";
        }
    
        # 选择得分最高的转录本，其CDS做为基因的信息
        @mRNA_ID = sort {$mRNA_score{$b} <=> $mRNA_score{$a} or $a cmp $b} @mRNA_ID;
        $gene_CDS{$gene_ID} = $mRNA_CDS{$mRNA_ID[0]};
        $gene_score{$gene_ID} = sprintf("%d", $mRNA_score{$mRNA_ID[0]});
        $gene_CDS_length{$gene_ID} = $mRNA_CDS_length{$mRNA_ID[0]};
    
        #print STDERR "$gene_ID\t$gene_score{$gene_ID}\n$gene_CDS{$gene_ID}\n";
    }
}
    
# 先找到两两有重叠的基因信息
my %overlap;
foreach my $gene_ID ( keys %gene_CDS ) {
    my ($chr, $strand) = ($chr{$gene_ID}, $strand{$gene_ID});
    # 对基因的CDS进行分析
    foreach my $CDS ( split /\n/, $gene_CDS{$gene_ID} ) {
        my ($start, $end) = split /\t/, $CDS;
        my $index1 = int($start / 1000);
        my $index2 = int($end / 1000);
        # 找到索引处对应的CDS的基因ID
        foreach my $index ( $index1 .. $index2 ) {
            foreach ( keys %{$cds2gene{$chr}{$strand}{$index}} ) {
                my @gene_ID = keys %{$cds2gene{$chr}{$strand}{$index}{$_}};
                @_ = split /\t/;
                # 若CDS有重叠
                if ( $_[1] >= $start && $_[0] <= $end ) {
                    foreach ( @gene_ID ) {
                        # 则找到相互重叠的关系
                        if ( $_ ne $gene_ID ) {
                            $overlap{$gene_ID}{$_} = 1;
                            $overlap{$_}{$gene_ID} = 1;
                        }
                    }
                }
            }
        }
    }
}

# 将相互有重叠的基因聚成一类
my %cluster;
while (%overlap) {
    my %cluster_one;
    
    # 挑出一个重叠的基因ID
    my @overlap = keys %overlap;
    my $one = shift @overlap;
    my @one;
    push @one, $one;

    # 循环找和该基因ID重叠的基因，放入一个聚类中
    while (@one) {
        $one = shift @one;
        $cluster_one{$one} = 1;
        if (exists $overlap{$one}) {
            foreach (keys %{$overlap{$one}}) {
                push @one, $_;
            }
            delete $overlap{$one};
        }
    }

    # 得到有重叠的基因类
    my $cluster = join "\t", sort keys %cluster_one;
    $cluster{$cluster} = 1;
}

# 对每类基因按得分从大到小排序，对有重叠的基因进行过滤
foreach my $cluster ( sort keys %cluster ) {
    my @genes = split /\t/, $cluster;
    @genes = sort {$gene_score{$b} <=> $gene_score{$a} or $a cmp $b} @genes;
    my %genes;
    foreach (@genes) { $genes{$_} = 1; }

     # 根据基因得分，从大到小删除
     while (@genes) {
         # 取出得分最高的基因ID，分析其CDS信息和长度
         my $gene = shift @genes;
         my @gene_CDS = split /\n/, $gene_CDS{$gene};
         my $gene_CDS_length = $gene_CDS_length{$gene};
         delete $genes{$gene};

         foreach my $target_gene (sort {$gene_score{$b} <=> $gene_score{$a}} keys %genes) {
             # 分析重叠类群中其它基因的CDS信息和长度
             my @target_gene_CDS = split /\n/, $gene_CDS{$target_gene};
             my $target_gene_CDS_length = $gene_CDS_length{$target_gene};

             # 检测两重叠基因重叠的比例
             my $match_CDS_length = &get_match_length(\@gene_CDS, \@target_gene_CDS);
             my $ratio1 = $match_CDS_length / $gene_CDS_length;
             my $ratio2 = $match_CDS_length / $target_gene_CDS_length;
             my $ratio = $ratio1;
             $ratio = $ratio2 if $ratio2 > $ratio1;

             if ( $ratio > $overlap_coverage ) {
                 print STDERR "Delete gene $target_gene (Score: $gene_score{$target_gene}), for its CDS coverage ratio with gene $gene (Score: $gene_score{$gene}) is: $ratio > $overlap_coverage\n";
                 # 去除得分较低的基因ID
                 delete $gene_CDS{$target_gene};
                 delete $genes{$target_gene};
             }
         }

         @genes = sort {$gene_score{$b} <=> $gene_score{$a} or $a cmp $b} keys %genes;
     }
}

# 按坐标排序输出GFF3结果
my @gene_ID = sort { $sort1{$a} cmp $sort1{$b} or $sort2{$a} <=> $sort2{$b} or $sort3{$a} <=> $sort3{$b} or $sort4{$a} cmp $sort4{$b} or $a cmp $b } keys %gene_info;
foreach my $gene_ID ( @gene_ID ) {
    next unless exists $gene_CDS{$gene_ID};
    print $gene_info{$gene_ID}{"header"};
    my @mRNA_ID = @{$gene_info{$gene_ID}{"mRNA_ID"}};
    foreach my $mRNA_ID ( sort @mRNA_ID ) {
        print $gene_info{$gene_ID}{"mRNA_header"}{$mRNA_ID};
        print $gene_info{$gene_ID}{"mRNA_info"}{$mRNA_ID};
    }
    print "\n";
}

sub get_match_length {
    my @region1 = @{$_[0]};
    my @region2 = @{$_[1]};

    my $out_length;
    my @region_match;
    foreach my $region1 (@region1) {
        my ($start1, $end1) = split /\t/, $region1;
        foreach my $region2 (@region2) {
            my ($start2, $end2) = split /\t/, $region2;
            if ($start1 < $end2 && $start2 < $end1) {
                my ($start, $end) = ($start1, $end1);
                $start = $start2 if $start2 > $start1;
                $end = $end2 if $end2 < $end1;
                push @region_match, "$start\t$end";
            }
        }
    }

    $out_length = &get_gene_CDS_length(\@region_match);
    return $out_length;
}

sub get_gene_CDS_length {
    my @region = @{$_[0]};
    @region = sort { $a <=> $b } @region;

    my $out_length;
    my $last_region = shift @region;
    @_ = split /\t/, $last_region;
    $out_length += ($_[1] - $_[0] + 1);
    foreach ( @region ) {
        my @last_region = split /\t/, $last_region;
        my @region = split /\t/;

        if ($region[0] > $last_region[1]) {
            $out_length += ($region[1] - $region[0] + 1);
            $last_region = $_;
        }
        elsif ($region[1] > $last_region[1]) {
            $out_length += ($region[1] - $last_region[1]);
            $last_region = $_;
        }
        else {
            next;
        }
    }

    return $out_length;
}


sub analysis_geneModels_integrity {
    my @CDS = @{$_[0]};
    my ($chr, $strand) = ($_[1], $_[2]);
    my $out;

    @CDS = sort {$a <=> $b} @CDS;
    my $seq;
    foreach ( @CDS ) {
        @_ = split /\t/;
        $seq .= substr($seq{$chr}, $_[0] - 1, $_[1] - $_[0] + 1);
    }
    if ( $strand eq "-" ) {
        $seq = reverse $seq;
        $seq =~ tr/ATCGatcgn/TAGCTAGCN/;
    }

    if ( $seq =~ m/^(\w{3})/ && exists $start_codon{$1} ) {
        if ( $seq =~ m/(\w{3})$/ && exists $stop_codon{$1} ) {
            $out = "complete";
        }
        else {
            $out = "3prime_partial";
        }
    }
    elsif ( $seq =~ m/(\w{3})$/ && exists $stop_codon{$1} ) {
        $out = "5prime_partial";
    }
    else {
        $out = "internal";
    }

    return $out;
}


sub get_geneModels_from_GFF3 {
    my %gene_info;
    my $input_file = $_[0];
    # 第一轮，找gene信息
    open IN, $input_file or die "Error: Can not open file $input_file, $!";
    while (<IN>) {
        if ( m/\tgene\t.*ID=([^;\s]+)/ ) {
            $gene_info{$1}{"header"} = $_;
        }
    }
    close IN;
    # 第二轮，找Parent值是geneID的信息，包含但不限于 mRNA 信息
    my %mRNA_ID2gene_ID;
    open IN, $input_file or die "Error: Can not open file $input_file, $!";
    while (<IN>) {
        if ( m/Parent=([^;\s]+)/ ) {
            my $parent = $1;
            if ( exists $gene_info{$parent} ) {
                if ( m/ID=([^;\s]+)/ ) {
                    push @{$gene_info{$parent}{"mRNA_ID"}}, $1;
                    $gene_info{$parent}{"mRNA_header"}{$1} = $_;
                    $mRNA_ID2gene_ID{$1} = $parent;
                }
            }
        }
    }
    close IN;
    # 第三轮，找Parent值不是geneID的信息
    open IN, $input_file or die "Error: Can not open file $input_file, $!";
    while (<IN>) {
        if ( m/Parent=([^;\s]+)/ && exists $mRNA_ID2gene_ID{$1} ) {
            my $parent = $1;
            $gene_info{$mRNA_ID2gene_ID{$1}}{"mRNA_info"}{$parent} .= $_;
        }
    }
    close IN;

    return %gene_info;
}


sub get_usage_english {

my $usage = <<USAGE;
Usage:
    $0 [options] genome.fasta in1.gff3 in2.gff3 in3.gff3 ...  > out.gff3 

    This program is designed to get rid of any unnecessary repetition in one or more GFF3 files containing gene models, evaluate the gene models, and choose the most reliable results.

    Here's how the program works:
    (1) It scores all input gene models. First, it gives points based on CDS length, with 1 point for each base pair, resulting in an initial score S. Then, it scores based on intron number, adding a certain percentage (relative to S) for each additional intron. The first intron adds the most points and subsequent ones add fewer proportionally. Also, the total points from all introns cannot exceed S. Next, it scores based on gene integrity by adding a certain percentage (relative to S) for a complete 5' end and another percentage for a complete 3' end. Finally, it adds a certain percentage (relative to S) to the score of the first input file while keeping the second input file's score unchanged. 
    (2) If two gene models overlap in the CDS and the overlap ratio of either model exceeds the threshold, the lower-scoring gene model will be removed based on their scores. First, the program will find gene clusters that overlap, and then it will remove redundant gene models within those clusters based on their scores from highest to lowest.

    Usage instructions:
    (1) The program needs a genome sequence as input to check the integrity of gene models.
    (2) This program can take in a GFF3 file with alternative splicing, score multiple transcripts of a gene, choose the CDS information from the transcript with the highest score as the gene's information, and then compare its overlap and scores with other gene models.

    --intron_score <float>    default: 0.3
    Set introns to increase the score of gene models proportionally. The increase in score of a gene model due to one intron = the parameter value; the increase in score of a gene model due to the second and other introns = (1 - the parameter value) ** (intron index - 1). That is, the increase in score due to multiple introns forms an infinite geometric series, with the first term = the parameter value, common ratio = (1 - the parameter value), and the sum of the infinite geometric series = 1. By default, the first term = 0.3, common ratio = 0.7, so the first intron increases the score by 30%, the second intron by 21%, the third intron by 14.7%, the fourth by 10.29%, and so on, until the increase in score due to all introns does not exceed 100%.

    --complete5p_score <float>    default: 0.5
    Set the gene model to increase the score proportionally when the 5' end is complete.

    --complete3p_score <float>    default: 0.5
    Set the gene model to increase the score proportionally when the 3' end is complete.

    --first_file_score <float>    default: 0.5
    Set the additional score percentage for the first input file. This helps prioritize gene models from the first input GFF3 file.

    --overlap_coverage <float>    default: 0.30
    Set a coverage threshold. Suppose the number of base pairs in the overlapping region of CDS between two gene models exceeds the coverage threshold divided by the number of redundant base pairs in the CDS of the smaller gene model. In that case, we need to remove the redundant gene model.

    --start_codon <string>    default: ATG
    Set the start codon. If there are multiple start codons, separate them with commas.

    --stop_codon <string>    default: TAA,TAG,TGA
    Set the stop codon. If there are multiple stop codons, separate them with commas.

    --help    default: None
    display this help and exit.

    --chinese_help    default: None
    display the chinese usage and exit.

USAGE

return $usage;
}
