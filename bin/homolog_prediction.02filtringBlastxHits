#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;

my $usage = <<USAGE;
Usage:
    $0 [options] blast.tab > filtered.tab

    对diamond blastx的结果进行过滤。先后采用两种方法进行过滤：（1）若Hits之间有包含关系时，仅保留指定数量（默认为10个）的较好Hits；（2）当两个Hits属于包含和被包含关系时，若其中一个得分较低（默认低于另一个得分的50%时），去除较低得分的比对结果。

    --threshold_num <int>    default: 10
    设置数量阈值。若Hits之间有包含关系时，仅保留指定数量（默认为10个）的较好Hits。分析过程分多步：（1）对和基因组3Kb窗口范围有重叠的所有Hits按匹配范围从大到小排序，然后依次进行后续分析；（2）若目标Hit包含有其它Hits，且其Evalue和Score都优于其它Hits，则对这些Hits按Evalue和Score进行排序，保留较好的指定数量（--threshold_num参数设置值）的Hits，删除其余较差的Hits；（3）对剩下未保留也未删除的Hits，延用第二步的策略，进一步的进行保留和删除操作，进行多轮直至分析完毕所有的Hit数据；（4）对整条基因组序列往后滑动，每次往后滑动1Kb距离，分析3Kb窗口，鉴定需要删除的的Hits信息。

    --threshold_ratio <float>    default: 0.4
    设置比例阈值。当两个BLAST Hits的匹配区域有包含关系时，A Hit包含B Hit，A Hit evalue优于B Hit evalue， 且B Hit Score / A Hit Score低于--threshold_ratio参数设置的阈值，则去除较低得分的比对结果。

    --help    default: None
    display this help and exit.

USAGE
if (@ARGV==0){die $usage}

my ($threshold_ratio, $threshold_num, $help_flag);
GetOptions(
    "threshold_ratio:f" => \$threshold_ratio,
    "threshold_num:i" => \$threshold_num,
    "help" => \$help_flag,
);
$threshold_ratio ||= 0.4;
$threshold_num ||= 10;

if ( $help_flag ) { die $usage }

# 读取所有的BLAST比对信息，并每1kb进行索引。
my $input_file = abs_path($ARGV[0]);
open IN, $input_file or die "Can not open file , $!";
my (%index, %score, %evalue, %alignment_length, %hits_all, %query, %query_start, %query_end);
while (my $line = <IN>) {
    $hits_all{$line} = 1;
    @_ = split /\t/, $line;
    my ($start, $end) = ($_[6], $_[7]);
    ($start, $end) = ($end, $start) if $start > $end;
    $start = int($start / 1000);
    $end = int($end / 1000) + 1;
    # 让每个索引位点，额外包括侧翼1Kb的区域。
    $start --; $start = 0 if $start < 0; $end ++;
    foreach ( $start .. $end ) {
        $index{$_[0]}{$_}{$line} = 1;
        $score{$line} = $_[-1];
        $evalue{$line} = $_[-2];
        $alignment_length{$line} = abs($_[6] - $_[7]) + 1;
        $query{$line} = $_[0];
        $query_start{$line} = $_[6];
        $query_end{$line} = $_[7];
    }
}
close IN;

my %hits_filtered;
#print STDERR "Seq_ID\tIndex_Num\tHit_Num\tRetained_Hit_num_after_--threshold_num\tRetained_Hit_num_after_--threshold_ratio\n";
foreach my $seq_ID ( sort keys %index ) {
    foreach my $index ( sort {$a <=> $b} keys %{$index{$seq_ID}} ) {
        my %hit = %{$index{$seq_ID}{$index}};
        my $num1 = %hit;
        next unless %hit;
        my @hit = sort { $alignment_length{$b} <=> $alignment_length{$a} or $evalue{$a} <=> $evalue{$b} or $score{$b} <=> $score{$b} or $a cmp $b } keys %hit;

        my (%keep);
        # 根据 --threshold_num 阈值过滤BLAST Hits
        while (@hit) {
            foreach my $hit ( @hit ) {
                # 对一个目标Hit进行分析
                # 找到所有被目标Hit包含的Hits，包含目标Hit本身
                my %be_contained_hit;
                @_ = split /\t/, $hit;
                my ($start, $end) = ($_[6], $_[7]);
                ($start, $end) = ($end, $start) if $start > $end;
                my $op = 1;
                foreach ( @hit ) {
                    @_ = split /\t/;
                    my ($start1, $end1) = ($_[6], $_[7]);
                    ($start1, $end1) = ($end1, $start1) if $start1 > $end1;
                    if ( $start1 >= $start && $end1 <= $end ) {
                        $be_contained_hit{$_} = 1;
                        # 若被包含的Hit优于目标Hit，则不需要进行过滤操作
                        if ( $score{$_} > $score{$hit} or $evalue{$_} < $evalue{$hit} ) {
                            $op = 0;
                            last;
                        }
                    }
                }
                # 若目标Hit优于所有被它包含的Hits，则执行保留和删除操作
                if ( $op == 1 ) {
                    my @be_contained_hit = sort { $evalue{$a} <=> $evalue{$b} or $score{$b} <=> $score{$a} or $a cmp $b } keys %be_contained_hit;
                    my $keep_num = 0;
                    foreach ( @be_contained_hit ) {
                        $keep_num ++;
                        if ( $keep_num <= $threshold_num ) {
                            $keep{$_} = 1;
                        }
                        else {
                            $hits_filtered{$_} = 1;
                        }
                        delete $hit{$_};
                    }
                }
            }
            # 下一轮的Hits，则去除了所有被保留和被删除的Hits。
            @hit = sort { $alignment_length{$b} <=> $alignment_length{$a} or $evalue{$a} <=> $evalue{$b} or $score{$b} <=> $score{$b} or $a cmp $b } keys %hit;
        }
        
        %hit = %keep;
        # 根据 --threshold_ratio 阈值过滤BLAST Hits
        next unless %hit;
        my $num2 = %hit;
        my @hit = keys %hit;
        FF1: foreach my $hit ( @hit ) {
            @_ = split /\t/, $hit;
            my ($start, $end) = ($_[6], $_[7]);
            ($start, $end) = ($end, $start) if $start > $end;
            foreach ( keys %hit ) {
                @_ = split /\t/;
                my ($start1, $end1) = ($_[6], $_[7]);
                ($start1, $end1) = ($end1, $start1) if $start1 > $end1;
                if ( $start >= $start1 && $end <= $end1 && $evalue{$hit} > $evalue{$_} && $score{$hit} < $score{$_} * $threshold_ratio ) {
                    delete $hit{$hit};
                    $hits_filtered{$hit} = 1;
                    next FF1;
                }
            }
        }
        my $num3 = %hit;
		#print STDERR "$seq_ID\t$index\t$num1\t$num2\t$num3\n";
    }
}

foreach ( sort { $query{$a} cmp $query{$b} or $query_start{$a} <=> $query_start{$b} or $query_end{$a} <=> $query_end{$b} or $a cmp $b } keys %hits_all ) {
    print unless exists $hits_filtered{$_};
}
my $hits_all_num = %hits_all;
my $hits_filtered_num = %hits_filtered;
my $remain_num = $hits_all_num - $hits_filtered_num;
print STDERR "Total Hits Number: $hits_all_num\nFiltered Hits Number: $hits_filtered_num\nRemained Hits Numer: $remain_num\n";
