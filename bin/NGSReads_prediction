#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $command_line = "$0 " . join(" ", @ARGV);
my $bin_path = dirname($0);
my $software_dir = $bin_path; $software_dir =~ s/\/bin$//;

my $usage = <<USAGE;
Usage:
    $0 [options] genome_seq.fasta > NGSReads_prediction.gff3

    本程序能利用RNA-Seq原始测序数据，对全基因组序列进行基因预测，并在标准输出中输出GFF3格式结果。

    程序流程和工作原理如下：
    (1) 首先，调用Trimmomatic软件对输入的FASTQ格式数据(支持多组数据，支持.gz压缩文件)进行质量控制，得到Clean data。
    (2) 然后，调用HISAT2软件将质控后的二代测序Reads比对到参考基因组序列上，得到SAM比对结果文件。此时也支持输入的SAM/BAM文件。
    (3) 然后，调用GETA软件中的Sam2Transfrag模块将SAM/BAM文件转换为转录本序列。
    (4) 然后，调用GETA软件中的Transfrag2ORF模块对转录本序列进行ORF预测得到基因模型。
    (5) 然后，调用GETA软件中的GFF3_filling_gene_models_Parallel命令，利用同源蛋白的基因模型对转录本预测的基因模型进行末端填补。
    (6) 然后，调用GETA软件中的GFF3Clear命令，对基因模型去冗余。
    (7) 然后，调用GETA软件中的fillingEndsOfGeneModels命令，对不完整基因模型的末端进行强制填补。
    (8) 最后，对基因模型进行分类和统计，并输出结果。

    程序使用须知：
    (1) 本程序支持双末端测序数据、单端测序数据和SAM/BAM三种不同的数据单独或混合输入。也支持.gz压缩文件作为输入。也支持同一类型多组数据作为输入。
    (2) 程序调用Trimmomatic、HISAT2和Sam2Transfrag软件进行分析时，可以使用参数配置文件方法调节这三个程序的详细参数。本程序调用这三个软件的默认参数请参照$software_dir/conf_all_defaults.txt文件。
    (3) 本程序调用Transfrag2ORF命令进行分析时，使用了Transdecoder软件对转录本进行ORF分析。其结果是每个ORF得到一个基因模型，此时可变剪接转录本会导致得到很多冗余基因模型。
    (4) 本流程第5步是可选步骤，若使用同源蛋白基因模型进行填补，能得到准确的完整基因模型；第7步强制填补后，得到的基因模型不一定准确。
    (5) 本流程最后将基因模型分成了四类并在标准错误输出中给出统计数量：A (Excellent gene models): 转录本预测或同源蛋白填补后的完整基因模型，且ORF占转录本序列比例>=50%；B (good gene models): 其它转录本预测或同源蛋白填补后的完整基因模型；C (fair gene models): 强制填补后的完整基因模型；Class D (poor gene models): 强制填补后也不完整的基因模型。
    (6) 在标准输出中给出GFF3结果，文件第9列各标签解读：Form，当前基因模型对应转录本上预测到的ORF数量和当前基因模型对应ORF占转录本序列的比例；Integrity，当前基因模型对应ORF的完整性；Filled_by_homolog=True，表示ORF预测不完整，却经过同源蛋白预测基因模型填补完整；Filling2Complete=True，表示ORF预测不完整，经过强制末端填补完整；Filling2Uncomplete=True，表示ORF预测不完整，经过强制末端填补后依然不完整；FragmentCount，表示当前基因模型支持的reads对数量；JunctionThreshold，获得其转录本时的最低intron测序深度阈值；BaseDepthThreshold，获得其转录本时的最低碱基测序深度阈值；MaxDepth，对应转录本的最高碱基测序深度；RNASeq_exon_base_depth_median，对应转录本的碱基测序深度中位数。

Parameters:
[输入参数]
    --pe1 <string> --pe2 <string>    default: None
    输入二代双末端测序的两个FASTQ格式文件。参数支持输入多对数据文件，使用逗号对不同文库的FASTQ文件路径进行分隔即可。参数也支持输入.gz格式的压 缩文件。

    --se <string>    default: None
    输入二代单端测序的FASTQ格式文件。参数支持输入多个数据文件，使用逗号对不同文库的FASTQ文件路径进行分隔即可。参数也支持输入.gz格式的压缩文件 。

    --sam <string>    default: None
    输入二代测序SAM格式数据文件。参数支持输入多个数据文件，使用逗号对不同的SAM文件路径进行分隔即可。参数也支持输入.bam格式的压缩文件。此外，程序支持--pe1/--pe2、--se和--sam这三个参数全部或部分使用，则利用所有输入的数据进行基因组比对，再获取转录本序列进行基因预测。

    --strand_specific    default: None
    添加该参数后，则认为所有输入的二代数据是链特异性测序数据，程序则仅在转录本正义链上预测基因。使用链特异性测序数据并设置本参数后，当两相邻基因有重叠时，能准确预测其边界。

    --config <string>    default: None
    输入一个参数配置文件路径，用于设置本程序调用的Trimmomatic、HISAT2和Sam2Transfrag软件的详细参数。若不输入该参数，则调用以上三个软件时，采用了本程序内置的默认参数，能适合大部分情形。

    --homolog_gene_models <string>    default: None
    输入同源蛋白预测的基因模型GFF3文件，用于对不完整基因模型末端进行填补。

[输出参数]
    --help    default: None
    display this help and exit.

    --chinese_help    default: None
    使用该参数后，程序给出中文用法并退出。

    --tmp_dir <string>    default: tmp_\$date\$pid
    设置零时文件夹路径。

    --output_alignment_GFF3 <string>    default: None
    输出一个转录本和参考基因组的比对文件，非标准GFF3文件。

    --output_raw_GFF3 <string>    default: None
    输出利用转录本序列进行基因预测的初步结果，即本流程中第6步后的结果。该GFF3文件中的基因模型未经过末端强制填补，其结果是非常准确的，但会包含较多的不完整基因模型。

    --intron_info_out <String>
    设置intron信息文件的输出路径，其中包含可信的introns。

    --base_depth_out <String>
    设置exon上碱基测序深度信息文件的输出路径。


[阈值参数]
    --pe_used_pair_num <int>    default: 100000000
    设置程序利用的最大双末端测序read对数量。当输入的数据较多时，最多使用此数量的read对。若输入了多组数据，则从每组前面取相同比例的数据量。程序默认最大使用100M的read对。若按照PE150bp测序，则使用的数据量为30 Gb。

    --se_used_read_num <int>    default: 100000000
    设置程序利用的最大单端测序read数量。当输入的数据较多时，最多使用此数量的read。若输入了多组数据，则从每组前面取相同比例的数据量。程序默认最大使用100M的read。若按照SE150bp测序，则使用的数据量为15 Gb。

    --min_protein_length <int>    default: 100
    设置鉴定ORF时最小的protein长度。

    --genetic_code <int>    default: 1
    设置遗传密码。该参数对应的值请参考NCBI Genetic Codes: https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi。本参数主要生效于同源蛋白进行基因预测的步骤，或对基因模型首尾进行强制补齐时使用的起始密码子和终止密码子信息的情形。
    该参数在本流程第5和7个步骤中对不完整基因模型进行末端填补时，设置起始和终止密码时产生效力。

[性能参数]
    --cpu <int>    default: 8
    设置程序使用的CPU线程数。

    --put_massive_temporary_data_into_memory    default: None
    设置将海量的临时文件存放到内存中。这样能避免磁盘I/O不足而造成程序运行减缓，但需要消耗更多内存。本流程在很多步骤中对数据进行了分割，再通过 并行化来加速计算，但这对磁盘形成了极大的I/O负荷。因此，当磁盘性能较差时会严重影响计算速度。若系统内存充足，推荐添加本参数，从而将海量的临时数 据存放到代表内存的/dev/shm文件夹下，以加速程序运行。此外，程序在数据分割和并行化步骤运行完毕后，会自动删除/dev/shm中的临时数据以释放内存。
    该参数主要用于运行Sam2Transfrag模块时生效。

USAGE
my $usage_english = &get_usage_english();
if (@ARGV==0){die $usage_english}

my ($pe1, $pe2, $single_end, $sam, $cpu, $homolog_gene_models, $tmp_dir, $strand_specific, $config, $help, $chinese_help, $cmdString, $pe_used_pair_num, $se_used_read_num, $min_protein_length, $genetic_code, $output_alignment_GFF3, $output_raw_GFF3, $intron_info_out, $base_depth_out, $put_massive_temporary_data_into_memory);
GetOptions(
    "pe1:s" => \$pe1,
    "pe2:s" => \$pe2,
    "se:s" => \$single_end,
    "sam:s" => \$sam,
    "cpu:i" => \$cpu,
    "homolog_gene_models:s" => \$homolog_gene_models,
    "tmp_dir:s" => \$tmp_dir,
    "strand_specific" => \$strand_specific,
    "config:s" => \$config,
    "pe_used_pair_num:i" => \$pe_used_pair_num,
    "se_used_read_num:i" => \$se_used_read_num,
    "min_protein_length:i" => \$min_protein_length,
    "genetic_code:i" => \$genetic_code,
    "output_alignment_GFF3:s" => \$output_alignment_GFF3,
    "output_raw_GFF3:s" => \$output_raw_GFF3,
    "intron_info_out:s" => \$intron_info_out,
    "base_depth_out:s" => \$base_depth_out,
    "put_massive_temporary_data_into_memory!" => \$put_massive_temporary_data_into_memory,
    "help" => \$help,
    "chinese_help" => \$chinese_help,
);
if ( $chinese_help ) { die $usage }
if ( $help ) { die $usage_english }


# 在标准错误输出中给出程序的运行命令。
my $pwd = `pwd`;
my $programe_name = basename($0);
print STDERR "\n#################### $programe_name | Start ####################\n";
print STDERR "PWD: $pwd" . (localtime) . ": CMD: " . $command_line . "\n";
print STDERR "============================================\n";

########### 解析参数 #################
$genetic_code ||= 1;
$cpu ||= 8;
$pe_used_pair_num ||= 100000000;
$se_used_read_num ||= 100000000;
$min_protein_length ||= 100;

# 使用绝对路径
my $input_genome = abs_path($ARGV[0]);
$homolog_gene_models = abs_path($homolog_gene_models) if $homolog_gene_models;
$output_alignment_GFF3 = abs_path($output_alignment_GFF3) if $output_alignment_GFF3;
$output_raw_GFF3 = abs_path($output_raw_GFF3) if $output_raw_GFF3;
$intron_info_out = abs_path($intron_info_out) if defined $intron_info_out;
$base_depth_out = abs_path($base_depth_out) if defined $base_depth_out;

# 准备RNA-Seq输入数据路径
my (%pe_reads, %se_reads, %SAM_files);
if ($pe1 && $pe2) {
    my @pe1 = split /,/, $pe1;
    my @pe2 = split /,/, $pe2;
    my $pe1_num = @pe1;
    my $pe2_num = @pe2;
    if ($pe1_num != $pe2_num) { die "the input file number of -1 was not equal to -2.\n" };
    foreach (@pe1) {
        $_ = abs_path($_);
        my $pe_file = $_;
        $_ = shift @pe2;
        $_ = abs_path($_);
        $pe_file .= "\t$_";
        $pe_reads{$pe_file} = 1;
    }
}
if ($single_end) {
    my @se = split /,/, $single_end;
    foreach (@se) {
        $_ = abs_path($_);
        $se_reads{$_} = 1;
    }
}
if ($sam) {
    my @sam = split /,/, $sam;
    foreach (@sam) {
        $_ = abs_path($_);
        $SAM_files{$_} = 1;
    }
}
unless (($pe1 && $pe2) or $single_end or $sam) {
    die "The RNA-Seq reads should be provided by parameters --pe1 --pe2 or --se or --sam .\n";
}

# 准备本程序调用程序的详细参数
my %config = (
    'trimmomatic' => 'TruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50 TOPHRED33',
    'hisat2' => '--min-intronlen 20 --max-intronlen 20000 --dta --score-min L,0.0,-0.4 -k 1',
    'Sam2Transfrag' => '--fraction 0.05 --min_expressed_base_depth 2 --max_expressed_base_depth 50 --min_junction_depth 2 --max_junction_depth 50 --min_fragment_count_per_transfrag 10',
);
if ($config) {
    open IN, $config or die "Can not open file $config, $!\n";
    my $tag;
    while (<IN>) {
        next if m/^#/;
        next if m/^\s*$/;
        s/^\s+//;
        s/\n/ /;
        if (/\[(.*)\]/) { $tag = $1; delete $config{$1}; }
        else { $config{$tag} .= $_; }
    }
    close IN;
}

# 准备临时文件夹路径
my $date = `date +%Y%m%d%H%M%S`; chomp($date);
$tmp_dir ||= "tmp_$date$$";
$tmp_dir = abs_path($tmp_dir);
mkdir $tmp_dir unless -e $tmp_dir;
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n";
###############################

# 检测剩余可用内存量
my $MemAvailable = 0;
$MemAvailable = &get_MemAvailable();


# 1. 使用Trimmomatic软件对RNA-Seq reads进行质控
print STDERR "\nStep 1. Quality control of RNA-Seq reads by Trimmomatic software " . "(" . (localtime) . ")" . "\n";
my (@paired_end_reads_prefix, @single_end_reads_prefix);
unless (-e "01.trimmomatic.ok") {
    mkdir "$tmp_dir/a.trimmomatic" unless -e "$tmp_dir/a.trimmomatic";
    chdir "$tmp_dir/a.trimmomatic"; print STDERR "PWD: $tmp_dir/a.trimmomatic\n";

    # 计算Trimmomatic并行化数，同时考虑到单个Trimmomatic命令消耗16G内存。
    my $MemAvailable = &get_MemAvailable();
    my $paraFly_CPU = 1;
    $paraFly_CPU = $cpu / 8 if $paraFly_CPU < ($cpu / 8);
    $paraFly_CPU = $MemAvailable / 16000000 if $paraFly_CPU > ($MemAvailable / 16000000);
    $paraFly_CPU = 1 if $paraFly_CPU < 1;

    if ($pe1 && $pe2) {
        # 对双末端测序数据进行质控
        my @pe_reads = sort keys %pe_reads;
        my $pe_reads_num = @pe_reads;
        my $number = 0;
        open OUT, ">", "command.trimmomatic_pe.list" or die "Can not create file command.trimmomatic_pe.list, $!";
        print STDERR (localtime) . ": create file command.trimmomatic_pe.list.\n";
        foreach (@pe_reads) {
            $number ++;
            my $code = "0" x ( length($pe_reads_num) - length($number) ) . $number;
            @_ = split /\t/;
            if ( -s $_[0] && -s $_[1] ) {
                push @paired_end_reads_prefix, "reads$code";
                print OUT "java -jar $software_dir/Trimmomatic-0.38/trimmomatic-0.38.jar PE -threads 16 $_[0] $_[1] reads$code.1.fastq reads$code.1.unpaired.fastq reads$code.2.fastq reads$code.2.unpaired.fastq ILLUMINACLIP:$software_dir/Trimmomatic-0.38/adapters/$config{'trimmomatic'} &> reads$code.trimmomatic.log\n";
            }
        }
        close OUT;
        $cmdString = "ParaFly -c command.trimmomatic_pe.list -CPU $paraFly_CPU &> /dev/null";
        print STDERR (localtime) . ": CMD: $cmdString\n";

        unless ( system("$cmdString") == 0 ) {
            # 特殊情况下 Fastq 文件中碱基质量全部为固定的值时，Trimmomatic不能自动检测phred格式而运行失败。于是强制指定为phred33，符合常规情况。
            $cmdString = "perl -pe 's/ PE / PE -phred33 /' FailedCommands > command.trimmomatic_phred33; rm FailedCommands";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

            $cmdString = "ParaFly -c command.trimmomatic_phred33 -CPU $paraFly_CPU &> /dev/null";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        }

        # 检测双末端测序数据质控后的有效数据量
        my $toal_pair_num = 0;
        my %lib_pair_num;
        foreach my $prefix ( @paired_end_reads_prefix ) {
            open IN, "$prefix.trimmomatic.log" or die "Error: Can not open file $prefix.trimmomatic.log, $!";
            while (<IN>) {
                if ( m/Surviving:\s*(\d+)/ ) {
                    $lib_pair_num{$prefix} = $1;
                    $toal_pair_num += $1;
                }
            }
            close IN;
        }

        # 最多输出一定的数据量
        open OUT1, ">", "PE_reads.1.fastq" or die "Error: Can not create file PE_reads.1.fastq, $!";
        open OUT2, ">", "PE_reads.2.fastq" or die "Error: Can not create file PE_reads.2.fastq, $!";
        foreach my $prefix ( @paired_end_reads_prefix ) {
            # 计算最大输出的行数
            my $max_line_num = int($pe_used_pair_num / $toal_pair_num * $lib_pair_num{$prefix}) * 4;
            # 输出read1中的数据
            open IN, "$prefix.1.fastq" or die "Error: Can not open file $prefix.1.fastq, $!";
            my $line_num = 0;
            while (<IN>) {
                $line_num ++;
                last if $line_num > $max_line_num;
                print OUT1;
            }
            close IN;
            # 输出read2中的数据
            open IN, "$prefix.2.fastq" or die "Error: Can not open file $prefix.2.fastq, $!";
            my $line_num = 0;
            while (<IN>) {
                $line_num ++;
                last if $line_num > $max_line_num;
                print OUT2;
            }
            close IN;
        }
        close OUT1; close OUT2;
    }
    if ($single_end) {
        # 对单端数据进行质控
        my @se_reads = sort keys %se_reads;
        my $se_reads_num = @se_reads;
        my $number = 0;
        open OUT, ">", "command.trimmomatic_se.list" or die "Can not create file command.trimmomatic_se.list, $!";
        foreach (@se_reads) {
            $number ++;
            my $code = "0" x ( length($se_reads_num) - length($number) ) . $number;
            push @single_end_reads_prefix, "reads$code";
            @_ = split /\t/;
            print OUT "java -jar $software_dir/Trimmomatic-0.38/trimmomatic-0.38.jar SE -threads $cpu $single_end reads$code.fastq ILLUMINACLIP:$software_dir/Trimmomatic-0.38/adapters/$config{'trimmomatic'} &> reads$code.trimmomatic.log\n";
        }
        close OUT;
        $cmdString = "ParaFly -c command.trimmomatic_pe.list -CPU $paraFly_CPU &> /dev/null";
        print STDERR (localtime) . ": CMD: $cmdString\n";

        unless ( system("$cmdString") == 0 ) {
            $cmdString = "perl -pe 's/ SE / SE -phred33 /' FailedCommands > command.trimmomatic_phred33; rm FailedCommands";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

            $cmdString = "ParaFly -c command.trimmomatic_phred33 -CPU $paraFly_CPU &> /dev/null";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        }

        # 检测单端测序数据质控后的有效数据量
        my $toal_read_num = 0;
        my %lib_read_num;
        foreach my $prefix ( @single_end_reads_prefix ) {
            open IN, "$prefix.trimmomatic.log" or die "Error: Can not open file $prefix.trimmomatic.log, $!";
            while (<IN>) {
                if ( m/Surviving:\s*(\d+)/ ) {
                    $lib_read_num{$prefix} = $1;
                    $toal_read_num += $1;
                }
            }
            close IN;
        }

        # 最多输出一定的数据量
        open OUT, ">", "SE_reads.fastq" or die "Error: Can not create file SE_reads.fastq, $!";
        foreach my $prefix ( @single_end_reads_prefix ) {
            # 计算最大输出的行数
            my $max_line_num = int($se_used_read_num / $toal_read_num * $lib_read_num{$prefix}) * 4;
            # 输出read中的数据
            open IN, "$prefix.fastq" or die "Error: Can not open file $prefix.fastq, $!";
            my $line_num = 0;
            while (<IN>) {
                $line_num ++;
                last if $line_num > $max_line_num;
                print OUT;
            }
            close IN;
        }
        close OUT;
    }
    chdir "../";
    open OUT, ">", "01.trimmomatic.ok" or die $!; close OUT;
}
else {
    print STDERR "Skip Step 1 for the file 1.trimmomatic.ok exists\n";
}


# 2. HISAT2比对
print STDERR "\nStep 2: Aligning NGS reads to genome by HISAT2 " . "(" . (localtime) . ")" . "\n";
mkdir "$tmp_dir/b.hisat2" unless -e "$tmp_dir/b.hisat2";
unless (-e "02.hisat2.ok") {
    chdir "$tmp_dir/b.hisat2"; print STDERR "PWD: $tmp_dir/b.hisat2\n";

    # 构建基因组hisat2索引数据库
    my $hisat2build_cpu = $cpu;
    $hisat2build_cpu = 80 if $hisat2build_cpu > 80;
    $cmdString = "hisat2-build -p $hisat2build_cpu $input_genome genome &> hisat2-build.log\n";
    unless (-e "hisat2-build.ok") {
        print STDERR (localtime) . ": CMD: $cmdString\n";
        system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        open OUT, ">", "hisat2-build.ok" or die $!; close OUT;
    }
    else {
        print STDERR "CMD(Skipped): $cmdString\n";
    }

    # 将RNA-Seq reads比对到参考基因组
    # 能处理单端，双端，链特异性与链非特异性数据
    my $input;
    if ($pe1 && $pe2) {
        $input = "-1 ../a.trimmomatic/PE_reads.1.fastq -2 ../a.trimmomatic/PE_reads.2.fastq";
    }
    if ($single_end) {
        $input .= " -U ../1.trimmomatic/SE_reads.fastq"
    }
    if ($input && $strand_specific) {
        $input .= " --rna-strandness RF";
    }
    if ( $input ) {
        $cmdString = "hisat2 -x genome -p $cpu $input -S alignment.sam $config{'hisat2'} 2> hisat2.log";
        unless (-e "hisat2.ok") {
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
            open OUT, ">", "hisat2.ok" or die $!; close OUT;
        }
        else {
            print STDERR "CMD(Skipped): $cmdString\n";
        }
        $SAM_files{"alignment.sam"} = 1;
    }

    # 对SAM文件进行排序，整合处理。
    # samtools sort 命令最多消耗80%可用内存，并尽可能使用较多的CPU线程。
    $MemAvailable = &get_MemAvailable();
    my $samtools_sort_CPU = 1;
    $samtools_sort_CPU = $cpu if $cpu > 1;
    $samtools_sort_CPU = ($MemAvailable * 0.8 / 768 / 1024) if $samtools_sort_CPU > ($MemAvailable * 0.8 / 768 / 1024);
    $samtools_sort_CPU = 1 if $samtools_sort_CPU < 1;
    open OUT, ">", "command.samtools_sort.list" or die "Can not create file command.samtools_sort.list, $!";
    my (@sam_out, $sam_file_code);
    foreach ( sort keys %SAM_files ) {
        $sam_file_code ++; push @sam_out, "sam_input$sam_file_code.bam";
        $cmdString = "samtools sort -\@ $samtools_sort_CPU -o sam_input$sam_file_code.bam -O BAM $_";
        print OUT "$cmdString\n";
        print STDERR (localtime) . ": CMDs will be performed: $cmdString\n";
    }
    close OUT;

    $cmdString = "rm -rf *.bam.tmp* *.sorted.sam.tmp*";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    $cmdString = "ParaFly -c command.samtools_sort.list -CPU 1 &> /dev/null";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    $cmdString = "samtools merge -\@ $samtools_sort_CPU -O BAM alignment.bam " . join(" ", @sam_out);
    $cmdString = "ln -s sam_input1.bam alignment.bam" if @sam_out == 1;
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    $cmdString = "samtools index -\@ $cpu alignment.bam";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    chdir "../";
    open OUT, ">", "02.hisat2.ok" or die $!; close OUT;
}
else {
    print STDERR "Skip Step 2 for the file 02.hisat2.ok exists\n";
}


# 3. 根据RNA-Seq比对的SAM结果转换得到转录本序列
print STDERR "\nStep 3: We convert the transcript sequences based on the SAM results from RNA-Seq alignment." . "(" . (localtime) . ")" . "\n";
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n"; 

my @input_parameter =();
push @input_parameter, "--put_massive_temporary_data_into_memory" if defined $put_massive_temporary_data_into_memory;
push @input_parameter, "--strand_specific" if defined $strand_specific;
push @input_parameter, "--intron_info_out $intron_info_out"if defined $intron_info_out;
push @input_parameter, "--base_depth_out $base_depth_out" if defined $base_depth_out;
my $input_parameter = join " ", @input_parameter;
$cmdString = "$bin_path/Sam2Transfrag $config{'Sam2Transfrag'} $input_parameter --input_single_sorted_BAM_file --tmp_dir $tmp_dir/c.Sam2Transfrag --cpu $cpu --intron_info_out intron.txt --base_depth_out base_depth.txt $tmp_dir/b.hisat2/alignment.bam > transfrag.raw.gff3";

&execute_cmds($cmdString, "$tmp_dir/03.Sam2Transfrag.ok");


# 4. 调用Transdecoder软件对转录本序列进行ORF分析，得到编码蛋白转录本在基因组上的结构注释信息，并输出GFF3格式结果。
print STDERR "\nStep 4: Use the Transdecoder software to perform ORF analysis on transcript sequences, obtain structural annotation information of the coding protein transcripts on the genome, and output the results in GFF3 format. Please note that each ORF predicted on transcript is a separate gene model. Multiple alternative splicing of a single gene can result in multiple redundant gene models. (" . (localtime) . ")\n";
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n";

my @input_parameter =();
push @input_parameter, "--output_alignment_GFF3 $output_alignment_GFF3" if defined $output_alignment_GFF3;
push @input_parameter, "--min_protein_length $min_protein_length" if defined $min_protein_length;
my $input_parameter = join " ", @input_parameter;
$cmdString = "$bin_path/Transfrag2ORF --tmp_dir d.Transfrag2ORF $input_parameter $input_genome $tmp_dir/transfrag.raw.gff3 > transfrag.ORF.gff3";

&execute_cmds($cmdString, "$tmp_dir/04.Transfrag2ORF.ok");


# 5. 使用同源蛋白的基因预测结果对转录本预测的基因模型进行填补
print STDERR "\nStep 5: Use the gene prediction results of homologous proteins to fill in the ends of the gene model for transcript prediction. (" . (localtime) . ")\n";
@_ = &codon_table("$tmp_dir/codon.table");
my (%start_codon, %stop_codon, $start_codon, $stop_codon);
%start_codon = %{$_[1]};
%stop_codon = %{$_[2]};
$start_codon = join ",", sort keys %start_codon;
$stop_codon = join ",", sort keys %stop_codon;
if ( $homolog_gene_models ) {
    # 若使用了--homolog_gene_models参数，则额外有05.FillingGeneModelsByHomolog.yes文件，用于删除后续步骤的.ok文件。
    $cmdString = "rm -rf 05.FillingGeneModelsByHomolog.ok 06.GFF3Clear.ok 07.fillingEndsOfGeneModelsfillingEndsOfGeneModels.ok";
    &execute_cmds($cmdString, "$tmp_dir/05.FillingGeneModelsByHomolog.yes");

    $cmdString = "GFF3_filling_gene_models_Parallel --cpu $cpu --tmp_dir e.FillingGeneModelsByHomolog --ouput_filling_detail_tab e.FillingGeneModelsByHomolog.tab --start_codon $start_codon --stop_codon $stop_codon --attribute_for_filling_complete Filled_by_homolog=True $input_genome $tmp_dir/transfrag.ORF.gff3 $homolog_gene_models > transfrag.ORF_filledByHomolog.gff3";
}
else {
    $cmdString = "cp -a $tmp_dir/transfrag.ORF.gff3 transfrag.ORF_filledByHomolog.gff3";
}

&execute_cmds($cmdString, "$tmp_dir/05.FillingGeneModelsByHomolog.ok");


# 6. 对转录本预测的基因模型去冗余。
print STDERR "\nStep 6: Cut down on the repetitive gene models predicted from transcriptome data. (" . (localtime) . ")\n";
my @cmdString = ();
push @cmdString, "$bin_path/GFF3_merging_and_removing_redundancy_Parallel --cpu $cpu $input_genome --first_file_score 0.0 transfrag.ORF_filledByHomolog.gff3 > transfrag.gff3 2> /dev/null";
push @cmdString,  "$bin_path/GFF3Clear --GFF3_source NGSReads --genome $input_genome --gene_prefix transfrag --no_attr_add transfrag.gff3 > transfrag.genome.gff3 2> /dev/null";
push @cmdString, "rm -rf transfrag.gff3";

&execute_cmds(@cmdString, "$tmp_dir/06.removing_redundancy.ok");

if ( $output_raw_GFF3 ) {
    my $output_raw_GFF3_info;
    open IN, "transfrag.genome.gff3" or die "Error: Can note open file transfrag.genome.gff3, $!";
    $output_raw_GFF3_info = join "", <IN>;
    close IN;
    open OUT, ">", $output_raw_GFF3 or die "Error: Can not create file $output_raw_GFF3, $!";
    foreach ( split /\n\n/, $output_raw_GFF3_info ) {
        if (m/Integrity=complete/ && m/Form=.*?_([\d\.]+)\%/ && $1 >= 50) {
            s/(\tgene\t.*ID=[^;]+)/$1;Type=excellent_gene_models_predicted_by_NGSReads/;
        }
        print OUT "$_\n\n";
    }
    close OUT;
}


# 7. 对基因模型的5'或3'端进行强制补齐
print STDERR "\nStep 7: Enforcing padding at the 5' or 3' end of the gene model. (" . (localtime) . ")\n";
$cmdString = "$bin_path/fillingEndsOfGeneModels --start_codon $start_codon --stop_codon $stop_codon $input_genome transfrag.genome.gff3 > transfrag.genome_fillEnd.gff3 2> fillingEndsOfGeneModels.log";

&execute_cmds($cmdString, "$tmp_dir/07.fillingEndsOfGeneModels.ok");


# 8. 对基因模型进行分析，并输出结果。
print STDERR "\nStep 8: Diveding geng modelse into 4 classes. (" . (localtime) . ")\n";
print STDERR "Class A (Excellent gene models): Complete gene models predicted by transcripts, or filled in by homolog, meanwhile the ORF occupies at least 50% of the transcript sequence.\n";
print STDERR "Class B (good gene models): Other Complete gene models predicted by transcripts, or filled in by homolog.\n";
print STDERR "Class C (fair gene models): Complete gene models after enforcing padding at the 5' or 3' end of the gene model.\n";
print STDERR "Class D (poor gene models): Uncomplete gene models.\n";

open IN, "transfrag.genome_fillEnd.gff3" or die "Can not open file transfrag.genome_fillEnd.gff3, $!";
my ( $num0, $num1, $num2, $num3, $num4 ) = (0, 0, 0, 0, 0);
$/ = "\n\n";
while (<IN>) {
    $num0 ++;
    if (m/Integrity=complete/ or m/Filled_by_homolog=True/) {
        if (m/Form=.*?_([\d\.]+)\%/ && $1 >= 50) {
            s/(\tgene\t.*ID=[^;]+)/$1;Type=excellent_gene_models_predicted_by_NGSReads/;
            $num1 ++;
        }
        else {
            s/(\tgene\t.*ID=[^;]+)/$1;Type=good_gene_models_predicted_by_NGSReads/;
            $num2 ++;
        }
    }
    elsif ( m/Filling2Complete=True/ ) {
        s/(\tgene\t.*ID=[^;]+)/$1;Type=fair_gene_models_predicted_by_NGSReads/;
        $num3 ++;
    }
    elsif ( m/Filling2Uncomplete=True/ ) {
        s/(\tgene\t.*ID=[^;]+)/$1;Type=poor_gene_models_predicted_by_NGSReads/;
        $num4 ++;
    }
    print;
}
close IN;
print STDERR "\nFinally, total $num0 gene models were divided into 4 classes : A, $num1; B, $num2; C, $num3; D, $num4.\n";

print STDERR "============================================\n";
print STDERR "$programe_name complete successfully! " . "(" . (localtime) . ")" . "\n\n";
print STDERR "#################### $programe_name | End ####################\n";


# 检测服务器剩余可用内存容量，结果单位是 kB。
sub get_MemAvailable {
    open IN, "/proc/meminfo" or die "Can not open file /proc/meminfo, $!";
    my $MemAvailable;
    while (<IN>) {
        if (m/MemAvailable:\s*(\d+)\s*kB/) {
            $MemAvailable = $1;
            next;
        }
    }
    close IN;
    return $MemAvailable;
}

sub codon_table {
    my %code = (
        "TTT" => "F",
        "TTC" => "F",
        "TTA" => "L",
        "TTG" => "L",
        "TCT" => "S",
        "TCC" => "S",
        "TCA" => "S",
        "TCG" => "S",
        "TAT" => "Y",
        "TAC" => "Y",
        "TAA" => "X",
        "TAG" => "X",
        "TGT" => "C",
        "TGC" => "C",
        "TGA" => "X",
        "TGG" => "W",
        "CTT" => "L",
        "CTC" => "L",
        "CTA" => "L",
        "CTG" => "L",
        "CCT" => "P",
        "CCC" => "P",
        "CCA" => "P",
        "CCG" => "P",
        "CAT" => "H",
        "CAC" => "H",
        "CAA" => "Q",
        "CAG" => "Q",
        "CGT" => "R",
        "CGC" => "R",
        "CGA" => "R",
        "CGG" => "R",
        "ATT" => "I",
        "ATC" => "I",
        "ATA" => "I",
        "ATG" => "M",
        "ACT" => "T",
        "ACC" => "T",
        "ACA" => "T",
        "ACG" => "T",
        "AAT" => "N",
        "AAC" => "N",
        "AAA" => "K",
        "AAG" => "K",
        "AGT" => "S",
        "AGC" => "S",
        "AGA" => "R",
        "AGG" => "R",
        "GTT" => "V",
        "GTC" => "V",
        "GTA" => "V",
        "GTG" => "V",
        "GCT" => "A",
        "GCC" => "A",
        "GCA" => "A",
        "GCG" => "A",
        "GAT" => "D",
        "GAC" => "D",
        "GAA" => "E",
        "GAG" => "E",
        "GGT" => "G",
        "GGC" => "G",
        "GGA" => "G",
        "GGG" => "G",
    );
    my %start_codon;
    $start_codon{"ATG"} = 1;
    if ( $genetic_code == 1 ) {
        # The Standard Code
        #$start_codon{"TTG"} = 1;
        #$start_codon{"CTG"} = 1;
    }
    elsif ( $genetic_code == 2 ) {
        # The Vertebrate Mitochondrial Code
        $code{"AGA"} = "X";
        $code{"AGG"} = "X";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 3 ) {
        # The Yeast Mitochondrial Code
        $code{"ATA"} = "M";
        $code{"CTT"} = "T";
        $code{"CTC"} = "T";
        $code{"CTA"} = "T";
        $code{"CTG"} = "T";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 4 ) {
        # The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTA"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 5 ) {
        # The Invertebrate Mitochondrial Code
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 6 ) {
        # The Ciliate, Dasycladacean and Hexamita Nuclear Code
        $code{"TAA"} = "Q";
        $code{"TAG"} = "Q";
    }
    elsif ( $genetic_code == 9 ) {
        # The Echinoderm and Flatworm Mitochondrial Code
        $code{"AAA"} = "N";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"TGA"} = "W";
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 10 ) {
        # The Euplotid Nuclear Code
        $code{"TGA"} = "C";
    }
    elsif ( $genetic_code == 11 ) {
        # The Bacterial, Archaeal and Plant Plastid Code
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 12 ) {
        # The Alternative Yeast Nuclear Code
        $code{"CTG"} = "S";
        $start_codon{"CTG"} = 1;
    }
    elsif ( $genetic_code == 13 ) {
        # The Ascidian Mitochondrial Code
        $code{"AGA"} = "G";
        $code{"AGG"} = "G";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 14 ) {
        # The Alternative Flatworm Mitochondrial Code
        $code{"AAA"} = "N";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"TAA"} = "Y";
        $code{"TGA"} = "W";
    }
    elsif ( $genetic_code == 16 ) {
        # Chlorophycean Mitochondrial Code
        $code{"TAG"} = "L";
    }
    elsif ( $genetic_code == 21 ) {
        # Trematode Mitochondrial Code
        $code{"TGA"} = "W";
        $code{"ATA"} = "M";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"AAA"} = "N";
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 22 ) {
        # Scenedesmus obliquus Mitochondrial Code
        $code{"TCA"} = "X";
        $code{"TAG"} = "L";
    }
    elsif ( $genetic_code == 23 ) {
        # Thraustochytrium Mitochondrial Code
        $code{"TTA"} = "X";
        $start_codon{"ATT"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 24 ) {
        # Rhabdopleuridae Mitochondrial Code
        $code{"AGA"} = "S";
        $code{"AGG"} = "K";
        $code{"TGA"} = "W";
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 25 ) {
        # Candidate Division SR1 and Gracilibacteria Code
        $code{"TGA"} = "G";
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 26 ) {
        # Pachysolen tannophilus Nuclear Code
        # warning: The descritpions of initiation codons by 2 methods are confict according to the NCBI web site.
        $code{"CTG"} = "A";
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 27 ) {
        # Karyorelict Nuclear Code
        $code{"TAG"} = "Q";
        $code{"TAA"} = "Q";
    }
    elsif ( $genetic_code == 29 ) {
        # Mesodinium Nuclear Code
        $code{"TAA"} = "Y";
        $code{"TAG"} = "Y";
    }
    elsif ( $genetic_code == 30 ) {
        # Peritrich Nuclear Code
        $code{"TAA"} = "E";
        $code{"TAG"} = "E";
    }
    elsif ( $genetic_code == 31 ) {
        # Blastocrithidia Nuclear Code
        $code{"TGA"} = "W";
    }
    elsif ( $genetic_code == 33 ) {
        # Cephalodiscidae Mitochondrial UAA-Tyr Code
        $code{"TAA"} = "Y";
        $code{"TGA"} = "Y";
        $code{"AGA"} = "S";
        $code{"AGG"} = "K";
    }

    my %stop_codon;
    foreach ( keys %code ) {
        $stop_codon{$_} = 1 if $code{$_} eq "X";
    }

    return (\%code, \%start_codon, \%stop_codon);
}


# 子程序，用于执行调用的Linux命令，同时生成.ok文件。
sub execute_cmds {
    my $ok_file = pop @_;

    if ( -e $ok_file ) {
        foreach ( @_ ) {
            print STDERR "CMD(Skipped): $_\n";
        }
    }
    else {
        foreach ( @_ ) {
            print STDERR (localtime) . ": CMD: $_\n";
            system($_) == 0 or die "failed to execute: $_\n";
        }
        open OUT, ">", "$ok_file" or die $!; close OUT;
    }

    return 1;
}


sub get_usage_english {
my $usage = <<USAGE;
Usage:
    $0 [options] genome_seq.fasta > NGSReads_prediction.gff3

    This program can use RNA-Seq data (fastq/fq.gz/sam/bam format) to predict gene models for your species' whole genome sequence, and then output the results in GFF3 format to standard output.

    The process and how it works are as follows: 
    (1) First, we use the Trimmomatic software to preprocess the input FASTQ format data (it supports multiple datasets and .gz compressed files) in order to obtain clean data. 
    (2) Then, we use HISAT2 software to align the quality-controlled second-generation sequencing reads with the reference genome sequence to get a SAM alignment result file. It also supports input SAM/BAM files at this stage. 
    (3) Next, we utilize the Sam2Transfrag module in GETA software to convert the SAM/BAM file into transcript sequences. 
    (4) After that, we employ the Transfrag2ORF module in GETA software for ORF prediction on transcript sequences to obtain gene models. 
    (5) Subsequently, we apply GFF3_filling_gene_models_Parallel command in GETA software for filling in ends of predicted gene models using homologous protein gene models. 
    (6) We then use GFF3Clear command in GETA software for removing duplicate gene models. 
    (7) Following that, we utilize fillingEndsOfGeneModels command in GETA software for forcefully completing ends of incomplete gene models. 
    (8) Finally, we classify and statistically analyze the gene models and output results.

    Usage instructions:
    (1) This program can handle paired-end sequencing data, single-end sequencing data, and SAM/BAM data in single or a mix of these. It also supports .gz compressed files and multiple groups of the same type of data. 
    (2) When running Trimmomatic, HISAT2, and Sam2Transfrag for analysis, you can adjust their detailed parameters using a configuration file method. The default parameters are found in $software_dir/conf_all_defaults.txt. 
    (3) When using Transfrag2ORF for analysis, it uses Transdecoder software to analyze transcripts for ORFs. Each ORF gets a gene model; however, alternative splicing may lead to redundant gene models. 
    (4) Step 5 is optional; if homologous protein gene models are used for filling in, accurate complete gene models can be obtained. However, step 7 forces filling in and may not always result in accurate gene models. 
    (5) In the final step of this workflow, gene models are divided into four categories with statistical numbers provided: A (Excellent):  Complete gene models predicted by transcripts, or filled in by homolog, meanwhile the ORF occupies at least 50% of the transcript sequence; B (Good): Other Complete gene models predicted by transcripts, or filled in by homolog; C (Fair): Complete gene models after enforcing padding at the 5' or 3' end of the gene model; D (Poor): Gene models that remain incomplete even after being forced to fill them out.
    (6) GFF3 results are provided in the standard output, and The interpretation of the labels in the ninth column of the GFF3 file is as follows: Form, which indicates the number of ORFs predicted on the transcript corresponding to the current gene model and the pertange of ORF in transcript sequence; Integrity, representing the completeness of the predicted ORF for this gene model; Filled_by_homolog=True, indicating that although there was an incomplete ORF prediction, it has been filled in by a homologous protein prediction gene model; illing2Complete=True, showing that despite an incomplete ORF prediction, it has been completed through forced terminal filling; Filling2Uncomplete=True, signifying that even after being filled by forced terminal filling due to an incomplete ORF prediction, it remains incomplete; FragmentCount reveals how many read pairs support each gene model; JunctionThreshold denotes the lowest intron sequencing depth threshold used to obtain its transcript; BaseDepthThreshold represents the minimum base sequencing depth threshold used to obtain its transcript; BaseDepthThreshold is the minimum sequencing depth required to obtain its transcript; MaxDepth represents the highest sequencing depth for the corresponding transcript; RNASeq_exon_base_depth_median indicates the median sequencing depth for the corresponding transcript.


Parameters:
[INPUT]
    --pe1 <string> --pe2 <string>    default: None
    Enter one or more pairs of FASTQ format files from Paired-End next-generation sequencing technology. This parameter supports the input of multiple pairs of FASTQ files, using commas to separate the FASTQ file paths of different libraries. This parameter also accepts compressed files in .gz format.

    --se <string>    default: None
    Enter one or more FASTQ format files from Single-End next-generation sequencing technology. This parameter supports the input of multiple Single-End FASTQ files, using commas to separate the FASTQ file paths of different libraries. This parameter also accepts compressed files in .gz format.

    --sam <string>    default: None
    Enter one or more SAM format files from the output of alignment software such as HISTA2. This parameter supports the input of multiple SAM files, using commas to separate the SAM file paths. This parameter also accepts compressed files in .bam format. In addition, the program allows for the full or partial use of the three parameters --pe1/--pe2, --se, and --sam, then all of the input data are used for genome alignment to generate the transcript sequence for gene model prediction.

    --strand_specific    default: None
    When this parameter is added, all input next-generation sequencing data are treated as strand-specific, and the program will predict gene models only on the forward strand of the transcript. When two neighboring genes overlap in the genome, strand-specific sequencing data and this parameter can help accurately estimate gene borders.

    --config <string>    default: None
    Enter a parameter configuration file path to set the detailed parameters for the Trimmomatic, HISAT2, and Sam2Transfrag software used by this program. If no parameter configuration file is input, the default parameters built into this program will be used when calling the above three software, which are suitable for most cases.

    --homolog_gene_models <string>    default: None
    Enter a GFF3 format files from the gene prediction by homologous proteins, which can be used for filling end of gene models predicted by NGS reads.

[OUTPUT]
    --help    default: None
    display this help and exit.

    --chinese_help    default: None
    display the chinese usage and exit.

    --tmp_dir <string>    default: tmp_\$date\$pid
    Enter the path of temporary folder.

    --output_alignment_GFF3 <string>    default: None
    Output a transcript sequence alignment file in non-standard GFF3 format.

    --output_raw_GFF3 <string>    default: None
    Output preliminary GFF3 format of gene models predicted by transcripts. These gene models do not have forced filling of their ends, and the results are credible, but they contain more incomplete genome models.

    --intron_info_out <String>
    When this parameter is set, the reliable intron information will be stored in the specified file.

    --base_depth_out <String>
    When this parameter is set, the sequencing depth information for all bases will be output to a specified file.

[Threshold]
    --pe_used_pair_num <int>    default: 100000000
    The program uses the maximum number of paired-end sequencing reads available. When there's a lot of input data, it uses this number of read pairs at most. If multiple datasets are provided, an equal portion of data is taken from the start of each dataset. By default, the program utilizes up to 100 million read pairs. For PE150bp sequencing, it processes around 30 gigabytes of data.

    --se_used_read_num <int>    default: 100000000
    The program uses the maximum number of single-end sequencing reads available. When there's a lot of input data, it uses this number of read at most. If multiple datasets are provided, an equal portion of data is taken from the start of each dataset. By default, the program utilizes up to 100 million read. For SE150bp sequencing, it processes around 15 gigabytes of data.

    --min_protein_length <int>    default: 100
    Set the minimum protein length for identifying ORFs.

    --genetic_code <int>    default: 1
    Enter the genetic code. The values for this parameter can be found on the NCBI Genetic Codes website at: https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi. This parameter is mainly effective for the gene prediction steps through homologous proteins, as well as the situation where start and stop codon information is used for filling the end of incomplete gene models.

[Performance]
    --cpu <int>    default: 8
    Enter the number of CPU threads.

    --put_massive_temporary_data_into_memory    default: None
    Set up massive temporary files to be stored in memory. This prevents the program from running slowly due to insufficient disk I/O, but it requires more RAM. Many steps in this pipeline would split the input data into numerous pieces and then parallelize its command lines to speed up the computation, although this results in a significant I/O load on the disk. Therefore, low disk performance has a significant impact on computation speed. If your system memory is sufficient, you are advised to add this parameter so that massive temporary data can be stored in the /dev/shm folder, which represents the memory, to speed up program execution. In addition, the program automatically deletes temporary data in /dev/shm to free up memory after the data splitting and parallelization steps are completed.

USAGE

return $usage;
}
