#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $pwd = `pwd`; print STDERR "##########\nPWD: $pwd";
print STDERR (localtime) . ": CMD: $0 " . join(" ", @ARGV) . "\n##########\n";

my $bin_path = dirname($0);
my $software_dir = $bin_path; $software_dir =~ s/\/bin$//;

my $usage = <<USAGE;
Usage:
    $0 [options] genome_seq.fasta > NGSReads_prediction.gff3

    This program can use RNA-Seq data (fastq/fq.gz/sam/bam format) to predict gene models for your species' whole genome sequence, and then output the results in GFF3 format to standard output.

Parameters:
[INPUT]
    --pe1 <string> --pe2 <string>    default: None
    Enter one or more pairs of FASTQ format files from Paired-End next-generation sequencing technology. This parameter supports the input of multiple pairs of FASTQ files, using commas to separate the FASTQ file paths of different libraries. This parameter also accepts compressed files in .gz format.

    --se <string>    default: None
    Enter one or more FASTQ format files from Single-End next-generation sequencing technology. This parameter supports the input of multiple Single-End FASTQ files, using commas to separate the FASTQ file paths of different libraries. This parameter also accepts compressed files in .gz format.

    --sam <string>    default: None
    Enter one or more SAM format files from the output of alignment software such as HISTA2. This parameter supports the input of multiple SAM files, using commas to separate the SAM file paths. This parameter also accepts compressed files in .bam format. In addition, the program allows for the full or partial use of the three parameters --pe1/--pe2, --se, and --sam, then all of the input data are used for genome alignment to generate the transcript sequence for gene model prediction.

    --strand_specific    default: None
    When this parameter is added, all input next-generation sequencing data are treated as strand-specific, and the program will predict gene models only on the forward strand of the transcript. When two neighboring genes overlap in the genome, strand-specific sequencing data and this parameter can help accurately estimate gene borders.

    --config <string>    default: None
    Enter a parameter profile path to set the detailed parameters of other commands called by this program. This parameter configuration file adopts the same format as the GETA main program configuration file. It is used to set the detailed parameters of trimmomatic, hisat2, sam2transfrag, TransDecoder.LongOrfs and TransDecoder.Predict and other programs are called by this program. If you did not provide this parameter, the built-in default setting is used, which is suitable in most instances.

    --homolog_gene_models <string>    default: None
    Enter a GFF3 format files from the gene prediction by homologous proteins, which can be used for filling end of gene models predicted by NGS reads.

[OUTPUT]
    --tmp_dir <string>    default: tmp_\$date\$pid
    Enter the path of temporary folder.

    --output_alignment_GFF3 <string>    default: None
    Output a transcript sequence alignment file in non-standard GFF3 format.

    --output_raw_GFF3 <string>    default: None
    Output preliminary GFF3 format of gene models predicted by transcripts. These gene models do not have forced filling of their ends, and the results are credible, but they contain more incomplete genome models.

[Settings]
    --cpu <int>    default: 8
    Enter the number of CPU threads.

    --put_massive_temporary_data_into_memory    default: None
    Set up massive temporary files to be stored in memory. This prevents the program from running slowly due to insufficient disk I/O, but it requires more RAM. Many steps in this pipeline would split the input data into numerous pieces and then parallelize its command lines to speed up the computation, although this results in a significant I/O load on the disk. Therefore, low disk performance has a significant impact on computation speed. If your system memory is sufficient, you are advised to add this parameter so that massive temporary data can be stored in the /dev/shm folder, which represents the memory, to speed up program execution. In addition, the program automatically deletes temporary data in /dev/shm to free up memory after the data splitting and parallelization steps are completed.

    --genetic_code <int>    default: 1
    Enter the genetic code. The values for this parameter can be found on the NCBI Genetic Codes website at: https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi. This parameter is mainly effective for the gene prediction steps through homologous proteins, as well as the situation where start and stop codon information is used for filling the end of incomplete gene models.

    --help    default: None
    display this help and exit.

USAGE
if (@ARGV==0){die $usage}

my ($pe1, $pe2, $single_end, $sam, $cpu, $homolog_gene_models, $tmp_dir, $strand_specific, $config, $help_flag, $cmdString, $genetic_code, $output_alignment_GFF3, $output_raw_GFF3, $put_massive_temporary_data_into_memory);
GetOptions(
    "pe1:s" => \$pe1,
    "pe2:s" => \$pe2,
    "se:s" => \$single_end,
    "sam:s" => \$sam,
    "cpu:i" => \$cpu,
    "homolog_gene_models:s" => \$homolog_gene_models,
    "tmp_dir:s" => \$tmp_dir,
    "strand_specific" => \$strand_specific,
    "config:s" => \$config,
    "genetic_code:i" => \$genetic_code,
    "output_alignment_GFF3:s" => \$output_alignment_GFF3,
    "output_raw_GFF3:s" => \$output_raw_GFF3,
    "put_massive_temporary_data_into_memory!" => \$put_massive_temporary_data_into_memory,
    "help" => \$help_flag,
);
if ( $help_flag ) { die $usage }

########### 解析参数 #################
$genetic_code ||= 1;
$cpu ||= 8;

# 使用绝对路径
my $input_genome = abs_path($ARGV[0]);
$homolog_gene_models = abs_path($homolog_gene_models) if $homolog_gene_models;
$output_alignment_GFF3 = abs_path($output_alignment_GFF3) if $output_alignment_GFF3;
$output_raw_GFF3 = abs_path($output_raw_GFF3) if $output_raw_GFF3;

# 准备RNA-Seq输入数据路径
my (%pe_reads, %se_reads, %SAM_files);
if ($pe1 && $pe2) {
    my @pe1 = split /,/, $pe1;
    my @pe2 = split /,/, $pe2;
    my $pe1_num = @pe1;
    my $pe2_num = @pe2;
    if ($pe1_num != $pe2_num) { die "the input file number of -1 was not equal to -2.\n" };
    foreach (@pe1) {
        $_ = abs_path($_);
        my $pe_file = $_;
        $_ = shift @pe2;
        $_ = abs_path($_);
        $pe_file .= "\t$_";
        $pe_reads{$pe_file} = 1;
    }
}
if ($single_end) {
    my @se = split /,/, $single_end;
    foreach (@se) {
        $_ = abs_path($_);
        $se_reads{$_} = 1;
    }
}
if ($sam) {
    my @sam = split /,/, $sam;
    foreach (@sam) {
        $_ = abs_path($_);
        $SAM_files{$_} = 1;
    }
}
unless (($pe1 && $pe2) or $single_end or $sam) {
    die "The RNA-Seq reads should be provided by parameters --pe1 --pe2 or --se or --sam .\n";
}

# 准备本程序调用程序的详细参数
my %config = (
    'trimmomatic' => 'TruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:50 TOPHRED33',
    'hisat2' => '--min-intronlen 20 --max-intronlen 20000 --dta --score-min L,0.0,-0.4 -k 1',
    'NGSReads_prediction.01SplitSam' => '--min_fragment_per_region 10',
    'NGSReads_prediction.02sam2transfrag' => '--fraction 0.05 --min_expressed_base_depth 2 --max_expressed_base_depth 50 --min_junction_depth 2 --max_junction_depth 50 --min_fragment_count_per_transfrags 10 --min_intron_length 20',
    'TransDecoder.LongOrfs' => '-m 100 -G universal',
    'TransDecoder.Predict' => '--retain_long_orfs_mode dynamic',
);
if ($config) {
    open IN, $config or die "Can not open file $config, $!\n";
    my $tag;
    while (<IN>) {
        next if m/^#/;
        next if m/^\s*$/;
        s/^\s+//;
        s/\n/ /;
        if (/\[(.*)\]/) { $tag = $1; delete $config{$1}; }
        else { $config{$tag} .= $_; }
    }
    close IN;
}

# 准备临时文件夹路径
my $date = `date +%Y%m%d%H%M%S`; chomp($date);
$tmp_dir ||= "tmp_$date$$";
$tmp_dir = abs_path($tmp_dir);
mkdir $tmp_dir unless -e $tmp_dir;
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n";
###############################

# 检测剩余可用内存量
my $MemAvailable = 0;
$MemAvailable = &get_MemAvailable();


# 1. 使用Trimmomatic软件对RNA-Seq reads进行质控
print STDERR "\nStep 1. Quality control of RNA-Seq reads by Trimmomatic software " . "(" . (localtime) . ")" . "\n";
my (@paired_end_reads_prefix, @single_end_reads_prefix);
unless (-e "01.trimmomatic.ok") {
    mkdir "$tmp_dir/a.trimmomatic" unless -e "$tmp_dir/a.trimmomatic";
    chdir "$tmp_dir/a.trimmomatic"; print STDERR "PWD: $tmp_dir/a.trimmomatic\n";

    # 计算Trimmomatic并行化数，同时考虑到单个Trimmomatic命令消耗16G内存。
    my $MemAvailable = &get_MemAvailable();
    my $paraFly_CPU = 1;
    $paraFly_CPU = $cpu / 8 if $paraFly_CPU < ($cpu / 8);
    $paraFly_CPU = $MemAvailable / 16000000 if $paraFly_CPU > ($MemAvailable / 16000000);
    $paraFly_CPU = 1 if $paraFly_CPU < 1;

    if ($pe1 && $pe2) {
        my @pe_reads = sort keys %pe_reads;
        my $pe_reads_num = @pe_reads;
        my $number = 0;
        open OUT, ">", "command.trimmomatic_pe.list" or die "Can not create file command.trimmomatic_pe.list, $!";
        print STDERR (localtime) . ": create file command.trimmomatic_pe.list.\n";
        foreach (@pe_reads) {
            $number ++;
            my $code = "0" x ( length($pe_reads_num) - length($number) ) . $number;
            @_ = split /\t/;
            if ( -s $_[0] && -s $_[1] ) {
                push @paired_end_reads_prefix, "reads$code";
                print OUT "java -jar $software_dir/Trimmomatic-0.38/trimmomatic-0.38.jar PE -threads 16 $_[0] $_[1] reads$code.1.fastq reads$code.1.unpaired.fastq reads$code.2.fastq reads$code.2.unpaired.fastq ILLUMINACLIP:$software_dir/Trimmomatic-0.38/adapters/$config{'trimmomatic'} &> reads$code.trimmomatic.log\n";
            }
        }
        close OUT;
        $cmdString = "ParaFly -c command.trimmomatic_pe.list -CPU $paraFly_CPU &> /dev/null";
        print STDERR (localtime) . ": CMD: $cmdString\n";
        unless ( system("$cmdString") == 0 ) {
            # 特殊情况下 Fastq 文件中碱基质量全部为固定的值时，Trimmomatic不能自动检测phred格式而运行失败。于是强制指定为phred33，符合常规情况。
            $cmdString = "perl -pe 's/ PE / PE -phred33 /' FailedCommands > command.trimmomatic_phred33; rm FailedCommands";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

            $cmdString = "ParaFly -c command.trimmomatic_phred33 -CPU $paraFly_CPU &> /dev/null";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        }
    }
    if ($single_end) {
        my @se_reads = sort keys %se_reads;
        my $se_reads_num = @se_reads;
        my $number = 0;
        open OUT, ">", "command.trimmomatic_se.list" or die "Can not create file command.trimmomatic_se.list, $!";
        foreach (@se_reads) {
            $number ++;
            my $code = "0" x ( length($se_reads_num) - length($number) ) . $number;
            push @single_end_reads_prefix, "reads$code";
            @_ = split /\t/;
            print OUT "java -jar $software_dir/Trimmomatic-0.38/trimmomatic-0.38.jar SE -threads $cpu $single_end reads$code.fastq ILLUMINACLIP:$software_dir/Trimmomatic-0.38/adapters/$config{'trimmomatic'} &> reads$code.trimmomatic.log\n";
        }
        close OUT;
        $cmdString = "ParaFly -c command.trimmomatic_pe.list -CPU $paraFly_CPU &> /dev/null";
        print STDERR (localtime) . ": CMD: $cmdString\n";
        unless ( system("$cmdString") == 0 ) {
            $cmdString = "perl -pe 's/ SE / SE -phred33 /' FailedCommands > command.trimmomatic_phred33; rm FailedCommands";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

            $cmdString = "ParaFly -c command.trimmomatic_phred33 -CPU $paraFly_CPU &> /dev/null";
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        }
        system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    }
    chdir "../";
    open OUT, ">", "01.trimmomatic.ok" or die $!; close OUT;
}
else {
    print STDERR "Skip Step 1 for the file 1.trimmomatic.ok exists\n";

    # 跳过Trimmomatic步骤时，需要得到Clean data的数据文件名称，用于下个步骤的输入文件。
    if ($pe1 && $pe2) {
        my @pe_reads = sort keys %pe_reads;
        my $pe_reads_num = @pe_reads;
        my $number = 0;
        foreach (@pe_reads) {
            $number ++;
            my $code = "0" x ( length($pe_reads_num) - length($number) ) . $number;
            @_ = split /\t/;
            if ( -s $_[0] && -s $_[1] ) {
                push @paired_end_reads_prefix, "reads$code";
            }
        }
    }
    if ($single_end) {
        my @se_reads = sort keys %se_reads;
        my $se_reads_num = @se_reads;
        my $number = 0;
        foreach (@se_reads) {
            $number ++;
            my $code = "0" x ( length($se_reads_num) - length($number) ) . $number;
            push @single_end_reads_prefix, "reads$code";
        }
    }
}


# 2. HISAT2比对
print STDERR "\nStep 2: Aligning NGS reads to genome by HISAT2 " . "(" . (localtime) . ")" . "\n";
mkdir "$tmp_dir/b.hisat2" unless -e "$tmp_dir/b.hisat2";
unless (-e "02.hisat2.ok") {
    chdir "$tmp_dir/b.hisat2"; print STDERR "PWD: $tmp_dir/b.hisat2\n";

    # 构建基因组hisat2索引数据库
    my $hisat2build_cpu = $cpu;
    $hisat2build_cpu = 80 if $hisat2build_cpu > 80;
    $cmdString = "hisat2-build -p $hisat2build_cpu $input_genome genome &> hisat2-build.log\n";
    unless (-e "hisat2-build.ok") {
        print STDERR (localtime) . ": CMD: $cmdString\n";
        system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
        open OUT, ">", "hisat2-build.ok" or die $!; close OUT;
    }
    else {
        print STDERR "CMD(Skipped): $cmdString\n";
    }

    # 将RNA-Seq reads比对到参考基因组
    # 能处理单端，双端，链特异性与链非特异性数据
    my $input;
    if ($pe1 && $pe2) {
        my (@input_pe1, @input_pe2, $input_pe1, $input_pe2);
        foreach ( @paired_end_reads_prefix ) {
            push @input_pe1, "../a.trimmomatic/$_.1.fastq";
            push @input_pe2, "../a.trimmomatic/$_.2.fastq";
        }
        $input_pe1 = join ",", @input_pe1;
        $input_pe2 = join ",", @input_pe2;
        $input = "-1 $input_pe1 -2 $input_pe2";
    }
    if ($single_end) {
        my (@input_se, $input_se);
        foreach ( @single_end_reads_prefix ) {
            push @input_se, "../1.trimmomatic/$_.fastq";
        }
        $input_se = join ",", @input_se;
        $input .= " -U $input_se"
    }
    if ($input && $strand_specific) {
        $input .= " --rna-strandness RF";
    }
    if ( $input ) {
        $cmdString = "hisat2 -x genome -p $cpu $input -S alignment.sam $config{'hisat2'} 2> hisat2.log";
        unless (-e "hisat2.ok") {
            print STDERR (localtime) . ": CMD: $cmdString\n";
            system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
            open OUT, ">", "hisat2.ok" or die $!; close OUT;
        }
        else {
            print STDERR "CMD(Skipped): $cmdString\n";
        }
        $SAM_files{"alignment.sam"} = 1;
    }

    # 对SAM文件进行排序，整合处理。
    # samtools sort 命令最多消耗80%可用内存，并尽可能使用较多的CPU线程。
    $MemAvailable = &get_MemAvailable();
    my $samtools_sort_CPU = 1;
    $samtools_sort_CPU = $cpu if $cpu > 1;
    $samtools_sort_CPU = ($MemAvailable * 0.8 / 768 / 1024) if $samtools_sort_CPU > ($MemAvailable * 0.8 / 768 / 1024);
    $samtools_sort_CPU = 1 if $samtools_sort_CPU < 1;
    open OUT, ">", "command.samtools_sort.list" or die "Can not create file command.samtools_sort.list, $!";
    my (@sam_out, $sam_file_code);
    foreach ( sort keys %SAM_files ) {
        $sam_file_code ++; push @sam_out, "sam_input$sam_file_code.bam";
        $cmdString = "samtools sort -\@ $samtools_sort_CPU -o sam_input$sam_file_code.bam -O BAM $_";
        print OUT "$cmdString\n";
        print STDERR (localtime) . ": CMDs will be performed: $cmdString\n";
    }
    close OUT;

    $cmdString = "rm -rf *.bam.tmp* *.sorted.sam.tmp*";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    $cmdString = "ParaFly -c command.samtools_sort.list -CPU 1 &> /dev/null";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    $cmdString = "samtools merge -\@ $samtools_sort_CPU -O BAM alignment.bam " . join(" ", @sam_out);
    $cmdString = "ln -s sam_input1.bam alignment.bam" if @sam_out == 1;
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    $cmdString = "samtools index -\@ $cpu alignment.bam";
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";

    chdir "../";
    open OUT, ">", "02.hisat2.ok" or die $!; close OUT;
}
else {
    print STDERR "Skip Step 2 for the file 02.hisat2.ok exists\n";
}


# 3. 根据RNA-Seq比对的SAM结果转换得到转录本序列
print STDERR "\nStep 3: We convert the transcript sequences based on the SAM results from RNA-Seq alignment." . "(" . (localtime) . ")" . "\n";
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n"; 

my @input_parameter =();
push @input_parameter, "--put_massive_temporary_data_into_memory" if defined $put_massive_temporary_data_into_memory;
push @input_parameter, "--strand_specific" if defined $strand_specific;
my $input_parameter = join " ", @input_parameter;
$cmdString = "$bin_path/Sam2Transfrag $input_parameter --input_single_sorted_BAM_file --tmp_dir $tmp_dir/c.Sam2Transfrag --cpu $cpu --intron_info_out intron.txt --base_depth_out base_depth.txt $tmp_dir/b.hisat2/alignment.bam > transfrag.raw.gff3";

&execute_cmds($cmdString, "$tmp_dir/03.Sam2Transfrag.ok");


# 4. 调用Transdecoder软件对转录本序列进行ORF分析，得到编码蛋白转录本在基因组上的结构注释信息，并输出GFF3格式结果。
print STDERR "\nStep 4: Use the Transdecoder software to perform ORF analysis on transcript sequences, obtain structural annotation information of the coding protein transcripts on the genome, and output the results in GFF3 format. (" . (localtime) . ")\n";
chdir $tmp_dir; print STDERR "\nPWD: $tmp_dir\n";

my @input_parameter =();
push @input_parameter, "--output_alignment_GFF3 $output_alignment_GFF3" if defined $output_alignment_GFF3;
my $input_parameter = join " ", @input_parameter;
$cmdString = "$bin_path/Transfrag2ORF --tmp_dir d.Transfrag2ORF $input_parameter $input_genome $tmp_dir/transfrag.raw.gff3 > transfrag.ORF.gff3";

&execute_cmds($cmdString, "$tmp_dir/04.Transfrag2ORF.ok");


# 5. 使用同源蛋白的基因预测结果对转录本预测的基因模型进行填补
print STDERR "\nStep 5: Use the gene prediction results of homologous proteins to fill in the ends of the gene model for transcript prediction. (" . (localtime) . ")\n";
if ( $homolog_gene_models ) {
	$cmdString = "GFF3_filling_gene_models_Parallel --cpu $cpu --tmp_dir e.FillingGeneModelsByHomolog --ouput_filling_detail_tab e.FillingGeneModelsByHomolog.tab $input_genome $tmp_dir/transfrag.ORF.gff3 $homolog_gene_models > transfrag.ORF_fill1.gff3";
}
else {
	$cmdString = "/bin/cp -a $tmp_dir/transfrag.ORF.gff3 transfrag.ORF_fill1.gff3";
}

&execute_cmds($cmdString, "$tmp_dir/05.FillingGeneModelsByHomolog.ok");

if ( $output_raw_GFF3 ) {
    my $output_raw_GFF3_info;
    open IN, "transfrag.genome.fill1.gff3" or die "Error: Can note open file transfrag.genome.fill1.gff3, !";
    $output_raw_GFF3_info = join "", <IN>;
    close IN;
    open OUT, ">", $output_raw_GFF3 or die "Error: Can not create file $output_raw_GFF3, $!";
    print OUT $output_raw_GFF3_info;
    close OUT;
}

# 6 对预测的基因模型去冗余。
print STDERR "3.9 remove the redundancy gene models.\n";
$cmdString = "$bin_path/GFF3Clear --GFF3_source NGSReads --genome $input_genome --gene_prefix transfrag --no_attr_add transdecoder2ORF.gff3 > transfrag.genome.gff3 2> /dev/null";
unless (-e "09.remove_redundancy.ok") {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "09.remove_redundancy.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}


# 3.11 对基因模型进行强制补齐
@_ = &codon_table("$tmp_dir/codon.table");
my (%start_codon, %stop_codon, $start_codon, $stop_codon);
%start_codon = %{$_[1]};
%stop_codon = %{$_[2]};
$start_codon = join ",", sort keys %start_codon;
$stop_codon = join ",", sort keys %stop_codon;
print STDERR "3.11 Filling ends of gene models.\n";
$cmdString = "$bin_path/fillingEndsOfGeneModels --nonCompletedGeneModels transfrag.genome.nonFilled.gff3 --start_codon $start_codon --stop_codon $stop_codon $input_genome transfrag.genome.fill1.gff3 > transfrag.genome.fill2.gff3 2> fillingEndsOfGeneModels.log";
unless (-e "11.fillingEndsOfGeneModels.ok") {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "11.fillingEndsOfGeneModels.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

# 3.12 对基因模型进行分级。
print STDERR "3.12 Diveding geng modelse into 4 classes.\n";
$cmdString = "$bin_path/NGSReads_prediction.06ClassGeneModels transfrag.genome.fill2.gff3 transfrag.genome.nonFilled.gff3 > transfrag.genome.class.gff3 2> ClassGeneModels.log";
unless (-e "12.classGeneModels.ok") {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "12.classGeneModels.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

# 3.13 再次去冗余。由于强制补齐后，相邻基因容易冗余
print STDERR "3.13 remove the redundancy gene models and output final results.\n";
$cmdString = "$bin_path/GFF3Clear --GFF3_source NGSReads --genome $input_genome --gene_prefix transfrag --no_attr_add transfrag.genome.class.gff3 > transfrag.genome.final.gff3 2> /dev/null";
unless (-e "13.GFFClear.ok") {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "09.remove_redundancy.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

open IN, "transfrag.genome.final.gff3" or die "Can not open file transfrag.genome.final.gff3, $!";
my ( $num0, $num1, $num2, $num3, $num4 ) = (0, 0, 0, 0, 0);
while (<IN>) {
    if (m/\tgene\t/) {
        s/Integrity=/TransdecoderIntegrity=/;
        $num0 ++;
        if ( m/Type=excellent_gene_models_predicted_by_NGSReads/) { $num1 ++; }
        elsif ( m/Type=good_gene_models_predicted_by_NGSReads/) { $num2 ++; }
        elsif ( m/Type=fair_gene_models_predicted_by_NGSReads/) { $num3 ++; }
        elsif ( m/Type=poor_gene_models_predicted_by_NGSReads/) { $num4 ++; }
    }
    print;
}
close IN;
print STDERR "\nFinally, total $num0 gene models were divided into 4 classes : A, $num1; B, $num2; C, $num3; D, $num4.\n";


# 检测服务器剩余可用内存容量，结果单位是 kB。
sub get_MemAvailable {
    open IN, "/proc/meminfo" or die "Can not open file /proc/meminfo, $!";
    my $MemAvailable;
    while (<IN>) {
        if (m/MemAvailable:\s*(\d+)\s*kB/) {
            $MemAvailable = $1;
            next;
        }
    }
    close IN;
    return $MemAvailable;
}

sub codon_table {
    my %code = (
        "TTT" => "F",
        "TTC" => "F",
        "TTA" => "L",
        "TTG" => "L",
        "TCT" => "S",
        "TCC" => "S",
        "TCA" => "S",
        "TCG" => "S",
        "TAT" => "Y",
        "TAC" => "Y",
        "TAA" => "X",
        "TAG" => "X",
        "TGT" => "C",
        "TGC" => "C",
        "TGA" => "X",
        "TGG" => "W",
        "CTT" => "L",
        "CTC" => "L",
        "CTA" => "L",
        "CTG" => "L",
        "CCT" => "P",
        "CCC" => "P",
        "CCA" => "P",
        "CCG" => "P",
        "CAT" => "H",
        "CAC" => "H",
        "CAA" => "Q",
        "CAG" => "Q",
        "CGT" => "R",
        "CGC" => "R",
        "CGA" => "R",
        "CGG" => "R",
        "ATT" => "I",
        "ATC" => "I",
        "ATA" => "I",
        "ATG" => "M",
        "ACT" => "T",
        "ACC" => "T",
        "ACA" => "T",
        "ACG" => "T",
        "AAT" => "N",
        "AAC" => "N",
        "AAA" => "K",
        "AAG" => "K",
        "AGT" => "S",
        "AGC" => "S",
        "AGA" => "R",
        "AGG" => "R",
        "GTT" => "V",
        "GTC" => "V",
        "GTA" => "V",
        "GTG" => "V",
        "GCT" => "A",
        "GCC" => "A",
        "GCA" => "A",
        "GCG" => "A",
        "GAT" => "D",
        "GAC" => "D",
        "GAA" => "E",
        "GAG" => "E",
        "GGT" => "G",
        "GGC" => "G",
        "GGA" => "G",
        "GGG" => "G",
    );
    my %start_codon;
    $start_codon{"ATG"} = 1;
    if ( $genetic_code == 1 ) {
        # The Standard Code
        #$start_codon{"TTG"} = 1;
        #$start_codon{"CTG"} = 1;
    }
    elsif ( $genetic_code == 2 ) {
        # The Vertebrate Mitochondrial Code
        $code{"AGA"} = "X";
        $code{"AGG"} = "X";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 3 ) {
        # The Yeast Mitochondrial Code
        $code{"ATA"} = "M";
        $code{"CTT"} = "T";
        $code{"CTC"} = "T";
        $code{"CTA"} = "T";
        $code{"CTG"} = "T";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 4 ) {
        # The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTA"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 5 ) {
        # The Invertebrate Mitochondrial Code
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 6 ) {
        # The Ciliate, Dasycladacean and Hexamita Nuclear Code
        $code{"TAA"} = "Q";
        $code{"TAG"} = "Q";
    }
    elsif ( $genetic_code == 9 ) {
        # The Echinoderm and Flatworm Mitochondrial Code
        $code{"AAA"} = "N";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"TGA"} = "W";
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 10 ) {
        # The Euplotid Nuclear Code
        $code{"TGA"} = "C";
    }
    elsif ( $genetic_code == 11 ) {
        # The Bacterial, Archaeal and Plant Plastid Code
        $start_codon{"ATA"} = 1;
        $start_codon{"ATT"} = 1;
        $start_codon{"ATC"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 12 ) {
        # The Alternative Yeast Nuclear Code
        $code{"CTG"} = "S";
        $start_codon{"CTG"} = 1;
    }
    elsif ( $genetic_code == 13 ) {
        # The Ascidian Mitochondrial Code
        $code{"AGA"} = "G";
        $code{"AGG"} = "G";
        $code{"ATA"} = "M";
        $code{"TGA"} = "W";
        $start_codon{"ATA"} = 1;
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 14 ) {
        # The Alternative Flatworm Mitochondrial Code
        $code{"AAA"} = "N";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"TAA"} = "Y";
        $code{"TGA"} = "W";
    }
    elsif ( $genetic_code == 16 ) {
        # Chlorophycean Mitochondrial Code
        $code{"TAG"} = "L";
    }
    elsif ( $genetic_code == 21 ) {
        # Trematode Mitochondrial Code
        $code{"TGA"} = "W";
        $code{"ATA"} = "M";
        $code{"AGA"} = "S";
        $code{"AGG"} = "S";
        $code{"AAA"} = "N";
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 22 ) {
        # Scenedesmus obliquus Mitochondrial Code
        $code{"TCA"} = "X";
        $code{"TAG"} = "L";
    }
    elsif ( $genetic_code == 23 ) {
        # Thraustochytrium Mitochondrial Code
        $code{"TTA"} = "X";
        $start_codon{"ATT"} = 1;
        $start_codon{"GTG"} = 1;
    }
    elsif ( $genetic_code == 24 ) {
        # Rhabdopleuridae Mitochondrial Code
        $code{"AGA"} = "S";
        $code{"AGG"} = "K";
        $code{"TGA"} = "W";
        $start_codon{"GTG"} = 1;
        $start_codon{"CTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 25 ) {
        # Candidate Division SR1 and Gracilibacteria Code
        $code{"TGA"} = "G";
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 26 ) {
        # Pachysolen tannophilus Nuclear Code
        # warning: The descritpions of initiation codons by 2 methods are confict according to the NCBI web site.
        $code{"CTG"} = "A";
        $start_codon{"GTG"} = 1;
        $start_codon{"TTG"} = 1;
    }
    elsif ( $genetic_code == 27 ) {
        # Karyorelict Nuclear Code
        $code{"TAG"} = "Q";
        $code{"TAA"} = "Q";
    }
    elsif ( $genetic_code == 29 ) {
        # Mesodinium Nuclear Code
        $code{"TAA"} = "Y";
        $code{"TAG"} = "Y";
    }
    elsif ( $genetic_code == 30 ) {
        # Peritrich Nuclear Code
        $code{"TAA"} = "E";
        $code{"TAG"} = "E";
    }
    elsif ( $genetic_code == 31 ) {
        # Blastocrithidia Nuclear Code
        $code{"TGA"} = "W";
    }
    elsif ( $genetic_code == 33 ) {
        # Cephalodiscidae Mitochondrial UAA-Tyr Code
        $code{"TAA"} = "Y";
        $code{"TGA"} = "Y";
        $code{"AGA"} = "S";
        $code{"AGG"} = "K";
    }

    my %stop_codon;
    foreach ( keys %code ) {
        $stop_codon{$_} = 1 if $code{$_} eq "X";
    }

    return (\%code, \%start_codon, \%stop_codon);
}


# 子程序，用于执行调用的Linux命令，同时生成.ok文件。
sub execute_cmds {
    my $ok_file = pop @_;

    if ( -e $ok_file ) {
        foreach ( @_ ) {
            print STDERR "CMD(Skipped): $_\n";
        }
    }
    else {
        foreach ( @_ ) {
            print STDERR (localtime) . ": CMD: $_\n";
            system($_) == 0 or die "failed to execute: $_\n";
        }
        open OUT, ">", "$ok_file" or die $!; close OUT;
    }

    return 1;
}
