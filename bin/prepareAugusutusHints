#!/usr/bin/perl
use strict;
use Getopt::Long;
use File::Basename;
use Cwd qw/abs_path getcwd cwd/;

my $usage = <<USAGE;
Usage:
    perl $0 [options] evidence_gene_models.gff3 ... > hints.gff

    本程序用于生成augustus hints文件:
    (1) 利用一个或多个GFF3文件中的基因模型生成start、stop、CDS、CDSpart和intron hints信息。
    (2) 当基因模型中同时包含excellent和Integrity=complete关键词，或包含Filled_by_homolog=True关键词，则其基因模型是使用trainscript或homolog预测的完整准确基因模型，用于生成src=M的hints。再对剩下不完整基因模型中CDS总长度不低于过阈值且CDS数量不低于阈值的基因模型进行分析，生成src=E的hints。对其余较差的基因模型，生成src=P的hints。后续使用hints进行Augustus基因预测是，对不同类型hints设置不同的得分奖励系数，推荐设置M类型为1e100，E类型1e6/1e4，P类型1e3/100。
    (3) 推荐输入给本程序的文件为evidence_gene_models.gff3，它是transcript和homolog基因预测结果整合去冗余选择最优基因模型而来的。由于不包含冗余的基因模型，因此不会将其中的transcript和homolog来源的hints分别分配高权重的E低权重的P，而是根据CDS长度和数量分配不同的hints权重。
    (4) 本程序利用了GFF3文件中CDS和intron信息，需要GFF3文件中必须有CDS和intron信息，且GFF3文件不能包含可变剪接。
    (5) 使用 --intron_tab 参数额外输入一个表格文件，能额外生成 intron hints，设置src=E。使用 --intron_tab 参数额外输入一个表格文件，能额外生成 intron hints，设置src=E。

    --intron_tab <string>    default: None
    输入intron信息文件。该文件中每行表示一个intron的信息，使用制表符分隔。程序使用该文件第2~6列数据，它们分别是：基因组染色体序列名称、intron所在的正负链、intron起始位点、intron结束位点(该值大于前者)和得分(一般是支持的RNA-Seq reads数量)。

    --intron_GFF3 <string>    default: None
    输入GFF3格式文件。从该文件中的intron信息获取intron hints。

    --CDS_length <int>    default: None
    --CDS_num <int>    default: None
    --CDS_ratio <float>    default: 0.333
    设置基因模型CDS长度和个数阈值。当一个不完整基因模型的CDS总长度且CDS个数超过阈值时，则认为其hints更可靠，设置其src=E，否则设置src=P。程序默认自动计算CDS_length和CDS_num参数的值，先分析所有完整基因模型的CDS总长度和个数，从小到大排序，取--CDS_ratio参数设置的分位数作为其阈值。此外，优先使用--CDS_length或--CDS_num参数设置的阈值。

    --margin <int>    default: 20
    由基因模型的CDS信息得到exonpart或CDSpart hints信息时，每个CDS两端减去指定长度得到CDSpart的坐标：若CDS的长度超过80bp时，则CDSpart则是首尾各去除20bp后的区间；否则，CDSpart是中间一半的区间（首尾各去除四分之一）。

USAGE
if (@ARGV==0){die $usage}

my ($intron_tab, $intron_GFF3, $CDS_length, $CDS_num, $CDS_ratio, $margin);
GetOptions(
    "intron_tab:s" => \$intron_tab,
    "intron_GFF3:s" => \$intron_GFF3,
    "CDS_ratio:f" => \$CDS_ratio,
    "CDS_length:s" => \$CDS_length,
    "CDS_num:i" => \$CDS_num,
    "margin:s" => \$margin,
);
$margin ||= 20;
$CDS_ratio ||= 0.333;

$intron_tab = abs_path($intron_tab) if defined $intron_tab;
$intron_GFF3 = abs_path($intron_GFF3) if defined $intron_GFF3;

# 分析 CDS_length 和 CDS_num 阈值。
my (@CDS_length, @CDS_num);
foreach my $input_file ( @ARGV ) {
    open IN, $input_file or die "Can not open the file $input_file, $!\n";
    $/ = "\n\n";
    while ( my $gene_info = <IN> ) {
        next unless ( ($gene_info =~ m/excellent/ && $gene_info =~ m/Integrity=complete/) or $gene_info =~ /Filled_by_homolog=True/ );
        my ($length, $num);
        foreach ( split /\n/, $gene_info ) {
            @_ = split /\t/;
            if ( $_[2] eq "CDS" ) {
                $length += (abs($_[4] - $_[3]) + 1);
                $num ++;
            }
        }
        push @CDS_length, $length;
        push @CDS_num, $num;
    }
    $/ = "\n";
    close IN;
}
@CDS_length = sort {$a <=> $b} @CDS_length;
@CDS_num = sort {$a <=> $b} @CDS_num;
$CDS_length = $CDS_length[@CDS_length * $CDS_ratio] unless defined $CDS_length;
$CDS_num = $CDS_num[@CDS_num * $CDS_ratio] unless defined $CDS_num;
print STDERR "程序使用了的CDS_length和CDS_num阈值分别为$CDS_length和$CDS_num。\n";

# 分析trainscript和homolog预测的基因模型，获取hints。
# 根据同时包含有excellent和Integrity=complete关键词且CDS总长度超过阈值的基因模型，得到start、stop、intron和CDS hint，设置src=M。在输入的GETA中间文件NGSReads_prediction.raw.gff3中，表示transdecoder预测的完整ORF且占转录本比不低于50%；在输入的GETA中间文件homolog_prediction.raw.gff3中，表示和同源蛋白起始和终止完全匹配的完整基因模型。推荐输入NGSReads_prediction.raw.gff3和homolog_prediction.raw.gff3合并去冗余后的GFF3文件。
# 对包含ID=transfrag关键词的基因模型，得到start、stop、CDSpart和intron hint，设置src=E。
# 对包含ID=homolog关键词的基因模型，得到start、stop、CDSpart和intron hint，设置src=P。
my $grp_num = 0;
my ($num_M, $num_E, $num_P) = (0, 0, 0);
foreach my $input_file ( @ARGV ) {
    open IN, $input_file or die "Can not open the file $input_file, $!\n";
    $/ = "\n\n";
    while ( my $gene_info = <IN> ) {
        # 获得 chr, strand, geneID, CDS, intron 信息，也计算基因的总CDS长度。
        my ( $chr, $source, $strand, $geneID, @CDS, @intron, $total_CDS_length, %hints, $grp);
        foreach ( split /\n/, $gene_info ) {
            @_ = split /\t/;
            if ( $_[2] eq "gene" ) {
                $geneID = $1 if $_[8] =~ m/ID=([^;]+)/;
                ($chr, $source, $strand) = ($_[0], $_[1], $_[6]);
            }
            elsif ( $_[2] eq "CDS" ) {
                push @CDS, "$_[3]\t$_[4]\t$_[7]";
                $total_CDS_length += (abs($_[4] - $_[3]) + 1);
            }
            elsif ( $_[2] eq "intron" ) {
                push @intron, "$_[3]\t$_[4]";
            }
        }
        @CDS = sort {$a <=> $b} @CDS;
        @intron = sort {$a <=> $b} @intron;

        # 根据基因模型的准确性程度分配不同的权重类型。
        my ($src, $integrity);
        $integrity = $1 if $gene_info =~ m/Integrity=([^;]+)/;
        if ( ($gene_info =~ m/excellent/ && $integrity eq "complete") or $gene_info =~ /Filled_by_homolog=True/) {
            $src = "M"; $num_M ++;
        }
        elsif ( $total_CDS_length >= $CDS_length && @CDS >= $CDS_num ) {
            $src = "E"; $num_E ++;
        }
        else {
            $src = "P"; $num_P ++;
        }
           
        $grp_num ++;
        my $grp = "grp=${geneID}_$grp_num;";
        # 收集intron hints
        foreach ( @intron ) {
            $hints{"$chr\t$source\tintron\t$_\t1\t$strand\t\.\t${grp}src=$src;pri=4;"} = 1;
        }

        # 收集CDSpart hints
        foreach ( @CDS ) {
            @_ = split /\t/;
            # 获得CDSpart hint时，去除两侧翼一定长度。
            my ( $start, $end ) = &get_margin_region($_);
            if ( $src eq "M" ) {
                $hints{"$chr\t$source\tCDS\t$_[0]\t$_[1]\t1\t$strand\t$_[2]\t${grp}src=$src;pri=4;"} = 1;
            }
            else {
                $hints{"$chr\t$source\tCDSpart\t$start\t$end\t1\t$strand\t\.\t${grp}src=$src;pri=4;"} = 1;
            }
        }

        # 收集起始和终止密码子hint
        my ($start_info, $stop_info);
        if ($strand eq "+") {
            my ($ss1, $ss2) = split /\t/, $CDS[0];
            if ($ss2 - $ss1 >= 2) {
                my $ss3 = $ss1 + 2;
                $start_info = "$chr\t$source\tstart\t$ss1\t$ss3\t1\t$strand\t0\t${grp}src=$src;pri=4;";
            }
            ($ss1, $ss2) = split /\t/, $CDS[-1];
            if ($ss2 - $ss1 >= 2) {
                my $ss3 = $ss2 - 2;
                $stop_info = "$chr\t$source\tstop\t$ss3\t$ss2\t1\t$strand\t0\t${grp}src=$src;pri=4;";
            }
        }
        elsif ($strand eq "-") {
            my ($ss1, $ss2) = split /\t/, $CDS[-1];
            if ($ss2 - $ss1 >= 2) {
                my $ss3 = $ss2 - 2;
                $start_info = "$chr\t$source\tstart\t$ss3\t$ss2\t1\t$strand\t0\t${grp}src=$src;pri=4;";
            }
            ($ss1, $ss2) = split /\t/, $CDS[0];
            if ($ss2 - $ss1 >= 2) {
                my $ss3 = $ss1 + 2;
                $stop_info = "$chr\t$source\tstop\t$ss1\t$ss3\t1\t$strand\t0\t${grp}src=$src;pri=4;";
           }
        }
        if ( $src eq "M" ) {
            $hints{$start_info} = 1;
            $hints{$stop_info} = 1;
        }
        elsif ( $integrity eq "5prime_partial" ) {
            $hints{$start_info} = 1;
        }
        elsif ( $integrity eq "3prime_partial" ) {
            $hints{$stop_info} = 1;
        }


        # 对hints按坐标排序
        my (%sort1, %sort2, %sort3, %sort4);
        foreach (keys %hints) {
            @_ = split /\t/;
            $sort1{$_} = $_[0];
            $sort2{$_} = $_[3];
            $sort3{$_} = $_[4];
            $sort4{$_} = $_[6];
        }
        
        foreach (sort { $sort1{$a} cmp $sort1{$b} or $sort2{$a} <=> $sort2{$b} or $sort3{$a} <=> $sort3{$b} or $sort4{$a} cmp $sort4{$b} } keys %hints) {
            next unless $_;
            print "$_\n";
        }
    }

    $/ = "\n";
}

print STDERR "有 $num_M 个完整基因模型用于生成src=M类型的hints，表示手工修正的hints，推荐得分奖励系数为1e+100。
有 $num_E 个不完整基因模型(CDS数量>=$CDS_num且CDS总长度>=$CDS_length)用于生成src=E类型的hints，推荐Augsutsu进行基因预测时采用的得分奖励系数为1e4~1e6。
有 $num_P 个不完整基因模型(CDS数量<$CDS_num或CDS总长度<$CDS_length)用于生成src=P类型的hints，推荐Augustus进行基因预测时采用的得分奖励系数为100~1e3。\n";

# 根据intron文件获取intron hints。使用 Sam2Transfrag 命令得到 intron 是比较准确的，设置src=E。
if ( defined $intron_tab ) {
    open IN, $intron_tab or die "Can not open the file $intron_tab, $!\n";
    while (<IN>) {
        next if m/^#/;
        chomp;
        @_ = split /\t/;
        print "$_[1]\t\.\tintron\t$_[3]\t$_[4]\t$_[5]\t$_[2]\t\.\tsrc=E;mult=$_[5];pri=4;\n";
    }
    close IN;
}
if ( defined $intron_GFF3 ) {
    open IN, $intron_GFF3 or die "Can not open the file $intron_tab, $!\n";
    while (<IN>) {
        next if m/^#/;
        @_ = split /\t/;
        my $multi = 1;
        $multi = $1 if m/mult=(\d+)/;
        $multi = $_[5] if $_[5] >= 1;
        print "$_[0]\t$_[1]\t$_[2]\t$_[3]\t$_[4]\t$multi\t$_[6]\t$_[7]\tsrc=E;mult=$multi;pri=4;\n";
    }
}


sub get_margin_region {
    @_ = split /\t/, $_[0];

    my $margin_value = $margin;
    my $length = $_[1] - $_[0] + 1;
    if ($length < $margin * 4) {
        $margin_value = int($length / 4);
        $margin_value = 1 if $margin_value < 1;
    }
    my $start = $_[0] + $margin_value;
    my $end = $_[1] - $margin_value;

    return($start, $end);
}
