#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $userID = `id -u $ENV{"USER"}`; chomp($userID);
my $date = `date +%Y%m%d%H%M%S`; chomp($date);

my $usage = <<USAGE;
Usage:
    $0 [options] -c command.list -CPU 8

    程序对 command.list 文件中的命令进行并行化任务提交，将运行成功的命令写入到 command.list.completed 文件按中。程序中断后再次运行，能分析剩下的任务数量，并接续进行分析。
    程序能进行快速大规模批量化提交并运行任务：（1）将多个命令写入一个子文件中，再调用parallel命令并行化提交该子文件中的任务；（2）将command.list文件命令写入多个子文件夹，再调用多个parallel命令，放入后台运行。通过以上两种方法，可以同一时间批量化提交极其大量的任务，适合每个任务消耗微量计算资源的情形。若此时使用ParaFly软件，则提交任务的速度远慢于执行任务的速度，导致无法充分利用CPU计算资源，计算速度较慢。
    程序控制任务运行成功方法：给每个command.list中的任务尾部添加“ && touch dir.Success/task_code || touch dir.Failed/task_code”；再将所有任务放后台运行；每隔一定时间检测文件夹中的编号信息从而确定任务是否运行成功。

    -c <string>    default: None
    输入命令行List文件。文件中包含多个相互独立的命令。

    -CPU <int>    default: 8
    设置初始的任务并行数。程序运行途中，若对CPU计算利用率没有达到阈值，则程序自动提升任务并行数。整个程序运行过程中，程序动态调节任务并行数，以维持CPU利用率保持在设定阈值。

    --max_parallel_j <int>    default: 100
    程序调用了parallel并行化提交任务，本参数设置调用parallel命令时其 -j 参数的最大值。程序刚开始运行时，将parallel命令 -j 参数值 j 设置为 --CPU 和 --max_parallel_j 两个参数中的较小值；程序运行后，若并行数不断增大，j值会增大为 int(并行数 ** 0.5) ，直至 --max_parallel_j 参数设定的最大值为止。此外，程序运行时，将数量为 j 的命令写入到子文件中，调用 parallel 对子文件中的程序进行批量化任务提交。

    --ratio_to_max_threads <float>    default: 0.8
    程序自动设置并行化运行任务数，以使系统的所有计算资源开销达到最大线程数的指定比例(80%)。

    --refresh_time <int>    default: 1
    程序每隔指定时间(3秒)即检测任务完成情况后，并根据需要投递任务，同时输出一些信息：（1）还剩下的任务数；（2）当前正并行运行的任务数；（4）下一轮允许的最大并行任务数；（5）系统CPU使用率。

    --rounds_delay <int>    default: 1
    当自动修改了并发数后，需要再完至少指定轮数的检测后，才进行下一次并发数的修改。默认参数表示每轮都支持自动修改下一次的并发数。当任务中命令使用了多线程，且延迟一段时间才能使用到多线程时，考虑增大该参数值，以免并行初期检测到CPU利用率而增大并发数，导致提交任务过多，导致系统负载过高。

    --tmp_dir_prefix <string>    default: /run/user/$userID/parafly_tmp${date}_$$
    程序将任务数据，包括分隔的命令行任务、检测任务运行是否成功的提示文件等存放入到临时文件夹中。根据该参数指定的临时文件夹前缀，程序自动生成3个临时文件夹：（1）.cmds后缀文件夹存放命令行文件；（2）.Success后缀文件夹存放运行成功的命令编号；（3）.Failed后缀文件夹存放运行失败的命令编号。当运行的任务数量极大时，系统IO并行数量极大，在临时文件夹中生成的文件数量也极多，推荐将临时文件夹存放到性能较强的分区上。程序默认使用/run/user目录，即存放到了内存上。此外，还需要注意本程序没有自动删除临时文件夹的功能，程序运行完毕后需要自行手动删除。

    --help    default: None
    display this help and exit.

USAGE
if (@ARGV==0){die $usage}

my ($cmdline, $cpu, $max_parallel_j, $ratio_to_max_threads, $refresh_time, $rounds_delay, $tmp_dir_prefix, $help_flag, $previous_total, $previous_idle);
GetOptions(
    "c:s" => \$cmdline,
    "CPU:i" => \$cpu,
    "max_parallel_j:i" => \$max_parallel_j,
    "ratio_to_max_threads:f" => \$ratio_to_max_threads,
    "refresh_time:i" => \$refresh_time,
    "rounds_delay:i" => \$rounds_delay,
    "tmp_dir_prefix:s" => \$tmp_dir_prefix,
    "help" => \$help_flag,
);
if ( $help_flag ) { die $usage }

$cpu ||= 8;
$max_parallel_j ||= 100;
$ratio_to_max_threads ||= 0.8;
$refresh_time ||= 1;
$rounds_delay ||= 1;

# 检测parallel程序
my $version_info = `parallel --version`;
die "程序的正常运行需要依赖 GNU parallel，请先安装 parallel 后再使用本程序。\n" 
    unless $version_info =~ m/GNU parallel/;

# 生成临时文件夹
$tmp_dir_prefix ||= "/run/user/$userID/paraFly_tmp_${date}_$$";
my $tmp_dir1 = "$tmp_dir_prefix.Success";
my $tmp_dir2 = "$tmp_dir_prefix.Failed";
my $tmp_dir3 = "$tmp_dir_prefix.cmds";
mkdir $tmp_dir1 unless -e $tmp_dir1;
mkdir $tmp_dir2 unless -e $tmp_dir2;
mkdir $tmp_dir3 unless -e $tmp_dir3;
print STDERR "程序使用了临时文件目录：\n\t$tmp_dir1\n\t$tmp_dir2\n";
`rm -rf $tmp_dir1/*`;
`rm -rf $tmp_dir2/*`;

# 检测已经完成的命令
my %completed_task;
if ( -e "$cmdline.completed" ) {
    open IN, "$cmdline.completed" or die "Error: Can not open file $cmdline.completed, $!";
    while (<IN>) {
        $completed_task{$_} = 1;
    }
    close IN;
}

# 给未完成的命令进行编号
open IN, $cmdline or die "Error: Can not open file $cmdline, $!";
my (%task, @commands);
my $num = 0;
while (<IN>) {
    next if exists $completed_task{$_};
    next if m/^\s*$/;
    $num ++;
    $task{$num} = $_;
    chomp;
    push @commands, "$_ && touch $tmp_dir1/$num || touch $tmp_dir2/$num\n";
}
close IN;
print STDERR "程序将对 $num 个命令进行并行化运算。\n";

# 程序主要通过 $total_task_num 变量控制总的并行任务数。
# 若检测到CPU使用率没有达到设定，则动态增加 $total_task_num 的值。增加 ($ratio_to_max_threads - 当前CPU使用率) / 当前CPU使用率 * $total_task_num，且每轮最多增加 $total_task_num 。
my $total_task_num = $cpu;
# 设置每轮需要准备的任务数量
my $prepare_task_num = $cpu;
# 设置每轮正在运行的任务数量
my $runing_task_num = 0;

# 设置每个parallel命令并行提交的任务数。
my $parallel_j = $cpu;
$parallel_j = $max_parallel_j if $parallel_j > $max_parallel_j;
# 设置每个子命令文件包含的任务数，在本程序中，$command_num_in_each_chunk 和 $parallel_j 是相等的。即将数量为 j 的命令写入到子文件中，调用 parallel 对子文件中的命令进行批量化任务提交。
my $command_num_in_each_chunk = $parallel_j;

# 设置parallel任务编号
my $parallel_job = 0;
my ($round_num, $round_num1, $round_num2) = (0, 0, 0);

open OUT1, ">>", "$cmdline.completed";
open OUT2, ">", "$cmdline.failed";
while ( @commands || $runing_task_num > 0 ) {

    # 分析已经成功的任务
    foreach ( <$tmp_dir1/*> ) {
        my $num_completed = basename($_);
        print OUT1 $task{$num_completed};
        unlink $_;
        $prepare_task_num ++;
        $runing_task_num --;
    }

    # 分析已经失败的任务
    foreach ( <$tmp_dir2/*> ) {
        my $num_completed = basename($_);
        print OUT2 $task{$num_completed};
        unlink $_;
        $prepare_task_num ++;
        $runing_task_num --;
    }

    my $commands_num = @commands;
    print STDERR (localtime) . "还剩下 $commands_num 个任务，当前 $runing_task_num 个任务正在运行中; ";

    # 提交任务到后台运行
    while ( $prepare_task_num >= $command_num_in_each_chunk && @commands >= $command_num_in_each_chunk ) {
        # 将多个命令放入文件中
        $parallel_job ++;
        open OUT, ">", "$tmp_dir3/parallel_job$parallel_job"  or die $!;
        foreach ( 1 .. $command_num_in_each_chunk ) {
            my $cmdString = shift @commands;
            print OUT $cmdString;
            $prepare_task_num --;
            $runing_task_num ++;
        }
        close OUT;
        my $cmdString = "parallel -j $parallel_j < $tmp_dir3/parallel_job$parallel_job &> /dev/null & ";
        system($cmdString);
    }

    # 当剩余任务量极少时的收尾
    if ( @commands < $command_num_in_each_chunk ) {
        $parallel_job ++;
        open OUT, ">", "$tmp_dir3/parallel_job$parallel_job"  or die $!;
        while ( @commands ) {
            my $cmdString = shift @commands;
            print OUT $cmdString;
            $prepare_task_num --;
            $runing_task_num ++;
        }
        close OUT;
        my $cmdString = "parallel -j $parallel_j < $tmp_dir3/parallel_job$parallel_job &> /dev/null & ";
        system($cmdString);
    }

    sleep $refresh_time;

    # 检测CPU使用率
    my $cpu_usage = &get_cpu_usage();
    my $cpu_usage_per = $cpu_usage / 100;
    # 调整并行任务总数
    my $used_task = $total_task_num;
    $used_task = $runing_task_num if $runing_task_num > $used_task;
    my $add_task_num = ($ratio_to_max_threads - $cpu_usage_per) / $cpu_usage_per * $used_task;
    # 当连续 $rounds_delay 多轮CPU使用率过低时，才增加任务数；或连续多轮CPU使用率过高时，才降低任务数。
    if ( $add_task_num > 0 ) {
        $round_num1 ++;
        $round_num = $round_num1;
        $round_num2 = 0;
    }
    else {
        $round_num2 ++;
        $round_num = $round_num2;
        $round_num1 = 0;
    }
    # 多轮CPU使用率同时过低或过高后，调节任务数。调节后的任务数不得低于初始并行数。
    if ( $total_task_num + $add_task_num >= $cpu && $round_num >= $rounds_delay ) {
        $add_task_num = 1 if ($add_task_num > 0 && $add_task_num < 1);
        $add_task_num = int($add_task_num);
        $add_task_num = $total_task_num if $add_task_num > $total_task_num;
        if ( $add_task_num > 0 ) {
            $total_task_num += $add_task_num;
            $prepare_task_num += $add_task_num;
        }
        else {
            $total_task_num = $used_task + $add_task_num;
            $prepare_task_num = 0;
        }
        ($round_num, $round_num1, $round_num2) = (0, 0, 0);
    }
    print STDERR "下一轮允许最大并行数为 $total_task_num，CPU使用率为 $cpu_usage %。\n";

    # 调整parallel输入文件的命令数、parallel的并行提交数。$command_num_in_each_chunk = $parallel_j，即j值。程序运行后，若并行数不断增大，j值会增大为 int(并行数 ** 0.5) ，直至 --max_parallel_j 参数设定的最大值为止。
    my $value_j = int($total_task_num ** 0.5);
    $value_j = 1 if $value_j < 1;
    $parallel_j = $value_j if $value_j > $parallel_j;
    $parallel_j = $max_parallel_j if $parallel_j > $max_parallel_j;
    $command_num_in_each_chunk = $parallel_j;
}

# 程序运行完毕，删除中间文件夹
my $cmdString = "rm -rf $tmp_dir1 $tmp_dir2 $tmp_dir3";
system($cmdString);


sub get_cpu_usage {
    open IN, "/proc/stat" or die "Can not open file /proc/stat, $!";
    $_ = <IN>;
    close IN;

    my ($cpu, $user, $nice, $system, $idle, $iowait, $irq, $softirq, $steal, $guest, $guest_nice)
        = split /\s+/, $_;
    my $total = $user + $nice + $system + $idle + $iowait + $irq + $softirq + $steal;

    my $total_diff = $total - $previous_total;
    my $idle_diff = $idle -  $previous_idle;
    my $cpu_usage = sprintf("%.2f", ($total_diff - $idle_diff) / $total_diff * 100);

    $previous_total = $total;
    $previous_idle = $idle;

    return $cpu_usage;
}
