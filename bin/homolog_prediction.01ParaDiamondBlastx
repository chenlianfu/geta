#!/usr/bin/env perl

use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $binPath = dirname($0);

my $usage = <<USAGE;
Usage:
    $0 [options] homolog_proteins.fasta genome_seq.fasta > out.tab

    本程序用于将全基因组序列和临近物种的同源蛋白使用diamond blastx进行比对，得到制表符分割的比对结果。若使用dianmond命令直接对单个全基因组Fasta文件进行分析，单个diamond命令并不能一直占用单台服务器全部CPU线程，有很长时间的单线程运行阶段，从而导致程序运行速度较慢。因此，推荐使用本程序将基因组序列进行分割后并行化计算，从而加快计算速度。此外，本程序会调用parsing_blast_result.pl命令根据evalue、identity和subject coverage对BLASTX结果进行过滤，再进一步调用homolog_prediction.02RemoveRedundancyOfBlastxHits对BLASTX结果去冗余。

    --segmentSize <int>    default: 1000000
    --overlapSize <int>    default: 100000
    程序将基因组较长的序列进行分割，以加快diamond blastx的并行化比对速度；若单条序列长度超过1Mb， 则将单条序列进行切割，两条相邻的序列间重叠的长度为100kb。

    --cpu <int>    default: 8
    设置CPU线程数。本程序将本参数的值传递给diamond命令的--threads参数，表明单个diamond所使用的CPU线程；但diamond程序后半部分往往对CPU线程利用较少，往往只能使用1~4个CPU线程，因此本程序并行化运行diamond的数量为--cpu参数设置的值除以4；此外，考虑到diamond比较消耗内存，单个diamond程序消耗内存峰值10G，并行化运行diamond的数量最高为剩余内存量除以10G；当调用ParaFly并行化运行失败后，程序会使用1个并行数来运行diamond命令。

    --identity <float>    default: 0.2
    --evalue <float>    default: 1e-9
    --subject_coverage <float>    default: 0.3
    设置diamond blastx分析时的Identity、E-value和subject coverage阈值。

    --genetic_code <int>    default: 1
    设置遗传密码。该参数对应的值请参考NCBI Genetic Codes: https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi。

    --tmp_dir <string>    default: tmp_\$date\$pid
    程序运行时临时文件夹名称。

    --help    default: None
    display this help and exit.

USAGE
if (@ARGV==0){die $usage}

my ($segmentSize, $overlapSize, $cpu, $identity, $evalue, $subject_coverage, $genetic_code, $tmp_dir, $help_flag);
GetOptions(
    "segmentSize:i" => \$segmentSize,
    "overlapSize:i" => \$overlapSize,
    "cpu:i" => \$cpu,
    "identity:f" => \$identity,
    "evalue:f" => \$evalue,
    "subject_coverage:f" => \$subject_coverage,
    "genetic_code:i" => \$genetic_code,
    "tmp_dir:s" => \$tmp_dir,
    "help" => \$help_flag,
);
$segmentSize ||= 1000000;
$overlapSize ||= 100000;
$cpu ||= 8;
$identity ||= 0.2;
$evalue ||= 1e-9;
$subject_coverage ||= 0.3;
$genetic_code ||= 1;
my $date = `date +%Y%m%d%H%M%S`; chomp($date);
$tmp_dir ||= "tmp_$date$$";
$tmp_dir = abs_path($tmp_dir);
mkdir $tmp_dir unless -e $tmp_dir;

if ( $help_flag ) { die $usage }

my $input_protein = abs_path($ARGV[0]);
my $input_genome = abs_path($ARGV[1]);

my $pwd = `pwd`; print STDERR "##########\nPWD (Current Directory): $pwd";
print STDERR (localtime) . "CMD (Main Program): $0 " . join(" ", @ARGV) . "\n##########\n\n";


# 1 运行 diamond makedb 命令，将蛋白序列做成数据库。
print STDERR "1. run diamond makedb, get a protein database.\n";
chdir $tmp_dir;
my $pwd = `pwd`; print STDERR "PWD: $pwd";
my $cmdString = "diamond makedb --threads $cpu --db homolog --in $input_protein 2> 1.diamond_makedb.log";
unless (-e "1.diamond_makedb.ok") {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "1.diamond_makedb.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

# 2 运行 diamond blastx 命令将基因组序列比对到蛋白序列数据库上。注意 --max-target-seqs 参数设置为蛋白序列的数量。
print STDERR "2. split genome sequences, and get diamond blastx commands.\n";
unless ( -e "2.split_genome_seqs_and_get_cmds.ok" ) {
    # 获取蛋白序列数量
    open IN, $input_protein or die "Can not open file $input_protein, $!";
    my $protein_number = 0;
    while (<IN>) {
        $protein_number ++ if m/^>/;
    }
    close IN;
    # 将基因组序列按长度进行分割，得到diamond blastx命令
    open IN, $input_genome or die "Can not open file $input_genome, !";
    my (%seq, $seq_ID);
    while (<IN>) {
        chomp;
        if (m/^>(\S+)/) { $seq_ID = $1; }
        else { $seq{$seq_ID} .= $_; }
    }
    close IN;
    mkdir "split_genome_seqs" unless -e "split_genome_seqs";
    open CMD1, ">", "split_genome_seqs/command.diamond_blastx.list" or die "Can not create file split_genome_seq/command.diamond_blastx.list, $!";
    open CMD2, ">", "split_genome_seqs/command.RemoveRedundancyOfBlastxHits.list" or die "Can not create file split_genome_seq/command.RemoveRedundancyOfBlastxHits.list, $!";
    my @seq_ID;
    foreach my $seq_id ( sort keys %seq ) {
        my $seq = $seq{$seq_id};
        my $seq_length = length $seq;
        if ($seq_length > $segmentSize) {
            my @partion = &get_partition($seq_length, $segmentSize, $overlapSize);
            foreach (@partion) {
                my $start = $_ - 1;
                my $end = $start + $segmentSize;
                my $sub_seq = substr($seq, $start, $segmentSize);
                open OUT, ">", "split_genome_seqs/$seq_id.$start.fa" or die "Can not create file split_genome_seqs/$seq_id.$start.fa, $!\n";
                print OUT ">$seq_id\_start_$start\n$sub_seq\n";
                close OUT;
                push @seq_ID, "$seq_id.$start";
            }
        }
        else {
            open OUT, ">", "split_genome_seqs/$seq_id.0.fa" or die "Can not create file split_genome_seqs/$seq_id.0.fa, $!\n";
            print OUT ">$seq_id\_start_0\n$seq\n";
            close OUT;
            push @seq_ID, "$seq_id.0";
        }
    }
    foreach ( @seq_ID ) {
        print CMD1 "diamond blastx --threads $cpu --db homolog --query split_genome_seqs/$_.fa --out split_genome_seqs/$_.xml --outfmt 5 --sensitive --max-target-seqs $protein_number --evalue $evalue --id 20 --query-gencode $genetic_code --max-hsps 50 2> split_genome_seqs/$_.diamond_blastx.log; $binPath/parsing_blast_result.pl --type xml --no-header --max-hit-num $protein_number --evalue $evalue --CIP $identity --subject-coverage $subject_coverage --query-coverage 0 --HSP-num 50 --out-hit-confidence split_genome_seqs/$_.xml > split_genome_seqs/$_.tab\n";
        print CMD2 "$binPath/homolog_prediction.02RemoveRedundancyOfBlastxHits --threshold_HSP_distance 5000 --threshold_num 10 --threshold_ratio 0.4 split_genome_seqs/$_.tab > split_genome_seqs/$_.out 2>> split_genome_seqs/$_.RemoveRedundancyOfBlastxHits.log\n";
    }
    close CMD1; close CMD2;
    open OUT, ">", "2.split_genome_seqs_and_get_cmds.ok" or die $!; close OUT;
    my $sequence_number = @seq_ID;
    print STDERR "The genome was split to $sequence_number sequences.\n";
}
else {
    print STDERR "This step was skipped, for the file 2.split_genome_seqs_and_get_cmds.ok exists.\n";
}

# 3 并行化运行 diamond blastx 命令
# 按内存余量确定 diamond 的并行化数量。按单个 dianmond 命令峰值消耗 10 Gb 内存。
print STDERR "3. run diamond blastx.\n";
my $MemAvailable = &get_MemAvailable();
my $paraFly_CPU = 1;
$paraFly_CPU = $cpu / 4 if $paraFly_CPU < ($cpu / 4);
$paraFly_CPU = $MemAvailable / 10000000 if $paraFly_CPU > ($MemAvailable / 10000000);
$paraFly_CPU = 1 if $paraFly_CPU < 1;
$paraFly_CPU = int($paraFly_CPU + 0.5);
my $cmdString = "ParaFly -c split_genome_seqs/command.diamond_blastx.list -CPU $paraFly_CPU &> 3.ParaFly_diamond_blastx.log";
unless ( -e "3.ParaFly_diamond_blastx.ok" ) {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    if ( system("$cmdString") != 0 ) {
        $cmdString = "ParaFly -c split_genome_seqs/command.diamond_blastx.list -CPU 1 &>> 3.ParaFly_diamond_blastx.log";
        print STDERR (localtime) . ": CMD: $cmdString\n";
        system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    }
    open OUT, ">", "3.ParaFly_diamond_blastx.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

# 4. 对diamond blastx的结果去冗余
print STDERR "4. Remove redundancy of blastx results.\n";
$cmdString = "ParaFly -c split_genome_seqs/command.RemoveRedundancyOfBlastxHits.list -CPU $cpu &> 4.ParaFly_RemoveRedundancyOfBlastxHits.log";
unless ( -e "4.ParaFly_RemoveRedundancyOfBlastxHits.ok" ) {
    print STDERR (localtime) . ": CMD: $cmdString\n";
    system("$cmdString") == 0 or die "failed to execute: $cmdString\n";
    open OUT, ">", "4.ParaFly_RemoveRedundancyOfBlastxHits.ok" or die $!; close OUT;
}
else {
    print STDERR "CMD(Skipped): $cmdString\n";
}

# 5 汇总dimond的比对结果，并修正匹配的位置信息(之前打断基因组序列后，比对的位置需要进行修正)。
print STDERR "5. output the alignment results.\n";
foreach (<"split_genome_seqs/*.out">) {
    open IN, $_ or die "Can not open file $_, $!";
    while (<IN>) {
        @_ = split /\t/;
        my $pos = 0;
        $pos = $1 if $_[0] =~ s/_start_(\d+)//;
        $_[6] += $pos;
        $_[7] += $pos;
        print (join "\t", @_);
    }
    close IN;
}

sub get_MemAvailable {
    open IN, "/proc/meminfo" or die "Can not open file /proc/meminfo, $!";
    my $MemAvailable;
    while (<IN>) {
        if (m/MemAvailable:\s*(\d+)\s*kB/) {
            $MemAvailable = $1;
            next;
        }
    }
    close IN;
    return $MemAvailable;
}

sub get_partition {
    my ($length, $ss, $os) = @_;
    my @out;

    my $pos = 1;
    push @out, $pos;
    while (($pos + $ss - 1) < $length) {
        $pos = $pos + $ss - 1 - $os + 1;
        push @out, $pos;
    }
    return @out;
}
