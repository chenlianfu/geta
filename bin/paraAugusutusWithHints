#!/usr/bin/perl
use strict;
use Getopt::Long;
use Cwd qw/abs_path getcwd cwd/;
use File::Basename;

my $bin_path = dirname($0);

my $usage = <<USAGE;
Usage:
    perl $0 [options] genome.fasta hints.gff

    程序将基因组序列和hints信息分成多份，然后调用augustus进行并行化计算，最后合并并行化结果，得到最终的GFF3结果文件。注意：输入的额hints.gff3文件必须按染色体名和位置进行排序。

    --gene_prefix <string>    default: augustus
    设置基因ID前缀

    --species <string>    default: None
    设置用于进行Augustus基因预测的HMM模型数据。

    --cpu <int>    default: 1
    设置并行运行augustus命令的数目。

    --segmentSize <int>    default: 5000000
    --overlapSize <int>    default: 100000
    程序将基因组序列分割成单条进行基因预测；若单条序列长度超过5Mb，则将单条序列进行切割，分割成5Mb的序列后再进行基因预测；此时，两条相邻的序列间重叠的长度为100kb。

    --tmp_dir <string>    default: aug_para_with_hints.tmp
    设置临时文件夹

    --alternatives_from_evidence    default: None
    添加该参数后，Augustus会进行可变剪接分析。

    --min_intron_len <int>    default: 30
    设置augustus预测时最小的intron长度。

    --AUGUSTUS_CONFIG_PATH <string>    default: None
    设置AUGUSTUS软件的物种配置文件夹路径。在该路径下应该存在一个名为species的子文件夹，species文件夹下则存放物种名称文件夹。设置该参数有利于将物种配置文件存放到有权限读写的地方。需要注意的是：该参数比Linux下的\$AUGUSTUS_CONFIG_PATH优先级更高；该参数指定的路径下还应该存在cgp、extrinsic、model、parameters和profile文件夹，运行etraining/augustus命令时需要依赖相应的文件。

USAGE
if (@ARGV==0){die $usage}

my ($species, $cpu, $tmp_dir, $gene_prefix, $segmentSize, $overlapSize, $alternatives_from_evidence, $min_intron_len, $AUGUSTUS_CONFIG_PATH);
GetOptions(
    "species:s" => \$species,
    "cpu:i" => \$cpu,
    "tmp_dir:s" => \$tmp_dir,
    "gene_prefix:s" => \$gene_prefix,
    "segmentSize:i" => \$segmentSize,
    "overlapSize:i" => \$overlapSize,
    "min_intron_len:i" => \$min_intron_len,
    "alternatives_from_evidence!" => \$alternatives_from_evidence,
    "AUGUSTUS_CONFIG_PATH:s" => \$AUGUSTUS_CONFIG_PATH,
);

$gene_prefix ||= "augustus";
$cpu ||= 1;
$tmp_dir ||= 'aug_para_with_hints.tmp';
$segmentSize ||= 5000000;
$overlapSize ||= 100000;
$min_intron_len ||= 30;
die "The --species parameter not setted!\n" unless $species;
if ( $AUGUSTUS_CONFIG_PATH ) {
    $AUGUSTUS_CONFIG_PATH = abs_path($AUGUSTUS_CONFIG_PATH);
    $AUGUSTUS_CONFIG_PATH = "--AUGUSTUS_CONFIG_PATH=$AUGUSTUS_CONFIG_PATH";
}

open IN, $ARGV[0] or die $!;
my (%seq, $id);
while (<IN>) {
    chomp;
    if (/>(\S+)/) { $id = $1; }
    else { $seq{$id} .= $_; }
}
close IN;

open IN, $ARGV[1] or die $!;
my %hints;
while (<IN>) {
	@_ = split /\t/;
	$hints{$_[0]} .= $_;
}
close IN;

# extrinsic.cfg
# 给M E P不同类型的hints设置参数。(1) 添加individual_liability，表示当有组内有不满足要求的hint时，仅删除该hint，而不是像默认情况下删除整组的hints信息。(2) 添加1group1gene，表示程序尝试预测出一个能完全覆盖整组hints的基因模型，能有利于处理多组hints之间的Gaps，即有利于使用多组Hints预测出一个完整的基因。例如，两个ESTs分别比对到一个基因的5'和3'端时，得到了两组Hints，添加1group1gene后，程序有利于将两组hints合并预测出一个基因。
# 同时有intron和CDSpart hints时，推荐设置CDSpart的得分系数高于intron，这样有利于AUGUSTUS调整不正确的intron，得到更准确的基因模型。本软件中CDSpart的得分系数时intron的一百倍。
# 起始密码子和终止密码子对基因预测的影响可能时最大的，设置其得分系数最高。
# Feature(CDS CDSpart intron)后紧跟两个数据，第一个是奖励系数，第二个是惩罚系数。第二个值越小，则表示没有hints支持时，更谨慎地预测基因，即最终预测的基因数量越少，specificity越高。
my $extrinsic = '[SOURCES]
M RM E W P

[SOURCE-PARAMETERS]
M individual_liability 1group1gene
E individual_liability 1group1gene
P individual_liability 1group1gene

[GENERAL]
      start      1         1  M    1  1e+100  RM  1     1    E 1    1e6  W 1    1    P   1   100
       stop      1         1  M    1  1e+100  RM  1     1    E 1    1e6  W 1    1    P   1   100
        tss      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
        tts      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
        ass      1   1     1  M    1  1e+100  RM  1     1    E 1    100  W 1    1    P   1   100
        dss      1   1     1  M    1  1e+100  RM  1     1    E 1    100  W 1    1    P   1   100
   exonpart      1   1     1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
       exon      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
 intronpart      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
     intron      1     0.168  M    1  1e+100  RM  1     1    E 1    100  W 1    1e3  P   1   10
    CDSpart      1   1  0.99  M    1  1e+100  RM  1     1    E 1    1e3  W 1    1    P   1   100
        CDS      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
    UTRpart      1   1     1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
        UTR      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
     irpart      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1
nonexonpart      1         1  M    1  1e+100  RM  1     1.14 E 1    1    W 1    1    P   1   1
  genicpart      1         1  M    1  1e+100  RM  1     1    E 1    1    W 1    1    P   1   1';
open OUT, ">", "extrinsic.cfg" or die $!;
print OUT "$extrinsic\n";
close OUT;

mkdir $tmp_dir unless -e $tmp_dir;

# 对数据进行分隔，并生成命令行
my %out_id;
unless ( -e "$tmp_dir/split.ok" && -s "$tmp_dir/out_id.list" ) {
	# 输出augustus命令行
    open COM, ">", "$tmp_dir/command.augustus.list" or die $!;
    foreach my $seq_id (sort keys %seq) {
        my $seq = $seq{$seq_id};
        my $seq_length = length $seq;
        my $hints_info = $hints{$seq_id};
        my @hints_info = split /\n/, $hints_info;
    
		# 将染色体序列分隔成多份多段
        my @partion = &get_partition($seq_length, $segmentSize, $overlapSize);

		# 对染色体的每段进行数据提取
        foreach (@partion) {
			# 确定一段序列的起始和结束位点，以0作为起始。
            my $start = $_ - 1;
            my $end = $start + $segmentSize;
            my $sub_seq = substr($seq, $start, $segmentSize);

			# 输出基因组序列
            open OUT, ">", "$tmp_dir/$seq_id.$start.fasta" or die "Can not create file $seq_id.$start.fasta, $!\n";
            print OUT ">$seq_id\n$sub_seq\n";
            close OUT;
    
			# 输出hints信息
            open OUT, ">", "$tmp_dir/$seq_id.$start.gff" or die "Can not create file $seq_id.$start.gff, $!\n";
			foreach ( @hints_info ) {
				@_ = split /\t/;
				if ( $_[3] >= $start + 1 && $_[4] <= $end + 1 ) {
					my $feature_start = $_[3] - $start;
					my $feature_end = $_[4] - $start;
					print OUT "$_[0]\t$_[1]\t$_[2]\t$feature_start\t$feature_end\t$_[5]\t$_[6]\t$_[7]\t$_[8]\n";
				}
			}
            close OUT;

			# 输出augustus命令行信息
			my $alternatives_from_evidence_parameter = "";
			$alternatives_from_evidence_parameter = "--alternatives-from-evidence=true" if $alternatives_from_evidence;
			;
            print COM "augustus --gff3=on --species=$species $AUGUSTUS_CONFIG_PATH --hintsfile=$tmp_dir/$seq_id.$start.gff --extrinsicCfgFile=extrinsic.cfg --allow_hinted_splicesites=gcag,atac $alternatives_from_evidence_parameter --min_intron_len=$min_intron_len --softmasking=1 $tmp_dir/$seq_id.$start.fasta > $tmp_dir/$seq_id.$start.out\n";

            $out_id{$seq_id}{"$seq_id.$start"} = $start;
        }
	}
    close COM;

    open OUT, ">", "$tmp_dir/split.ok" or die $!; close OUT;

    open OUT, ">", "$tmp_dir/out_id.list" or die "Error: Can not create file $tmp_dir/out_id.list, $!";
    foreach my $seq_id ( sort keys %out_id ) {
        foreach ( sort {$out_id{$seq_id}{$a} <=> $out_id{$seq_id}{$b}} keys %{$out_id{$seq_id}} ) {
            print OUT "$seq_id\t$_\t$out_id{$seq_id}{$_}\n";
        }
    }
    close OUT;
}
else {
    open IN, "$tmp_dir/out_id.list" or die "Can not open file $tmp_dir/out_id.list, $!";
    while ( <IN> ) {
        chomp;
        @_ = split /\t/;
        $out_id{$_[0]}{$_[1]} = $_[2];
    }
}
    
my $cmdString = "ParaFly -c $tmp_dir/command.augustus.list -CPU $cpu &> $tmp_dir/command.augustus.log";
system ($cmdString) == 0 or die "Failed to execute: $cmdString\n$!\n";

# 转换坐标
my $gene_num = 0;
open CMD1, ">", "$tmp_dir/command.GFF3Clear.list" or die "Error: Can not create file $tmp_dir/command.GFF3Clear.list, $!";
open CMD2, ">", "$tmp_dir/command.GFF3_merging_and_removing_redundancy.list" or die "Error: Can not create file $tmp_dir/command.GFF3_merging_and_removing_redundancy.list, $!";
foreach my $seq_id (sort keys %out_id) {
    my @partition = sort {$out_id{$seq_id}{$a} <=> $out_id{$seq_id}{$b}} keys %{$out_id{$seq_id}};
    foreach my $par (@partition) {
        # 获得坐标初始值，真正的坐标需要增加该值。
        my $locus = $1 if $par =~ m/\.(\d+)$/;

        # 解析基因模型
        my (@gene_ID, $gene_ID, $old_gene_ID, %gene_info, %hints_supporting_ratio, %intron_supporting_info);
        open IN, "$tmp_dir/$par.out" or die "Can not open file $tmp_dir/$par.out, $!\n";
        while (<IN>) {
            # 修改GFF3格式和坐标。transcript更正为mRNA，起始和结束坐标增加初始值。
            @_ = split /\t/, $_;
            unless ( m/^#/ ) {
                $_[2] = "mRNA" if $_[2] eq "transcript";
                $_[3] += $locus;
                $_[4] += $locus;
                $_ = join "\t", @_;
            }

            # 得到基因新旧ID名称。
            if ( $_[2] eq "gene" ) {
                $gene_num ++;
                $gene_ID = "g$gene_num";
                push @gene_ID, $gene_ID;
                $old_gene_ID = $1 if $_[8] =~ m/ID=([^;\s]+)/;
            }
            # 将旧ID替换为新ID，并得到基因的信息，保存基因信息到到 %gene_info
            s/ID=$old_gene_ID/ID=$gene_ID/g;
            s/Parent=$old_gene_ID/Parent=$gene_ID/g;
            $gene_info{$gene_ID} .= $_;
            # 分析Hint比例
            $hints_supporting_ratio{$gene_ID} = $1 if m/^# \% of transcript supported by hints \(any source\)\: (\S+)/;
            $intron_supporting_info{$gene_ID} = $1 if m/^# CDS introns\: (\S+)/;
        }
        close IN;

        # 输出基因模型
        open OUT, ">", "$tmp_dir/$par.raw.gff3" or die  "Can not create file $tmp_dir/$par.raw.gff3, $!\n";
        foreach ( @gene_ID ) {
            my $out = $gene_info{$_};
            $out =~ s/(\tgene\t.*ID=[^;\s]+)/$1;hintRatio=$hints_supporting_ratio{$_};intronSupport=$intron_supporting_info{$_}/;
            print OUT $out;
        }
        close OUT;

        # 输出GFF3Clear命令行
        print CMD1 "$bin_path/GFF3Clear --genome $ARGV[0] --no_attr_add $tmp_dir/$par.raw.gff3 > $tmp_dir/$par.gff3 2> $tmp_dir/$par.GFF3Clear.log\n";
    }

    # 输出GFF3_merging_and_removing_redundancy命令
    print CMD2 "$bin_path/GFF3_merging_and_removing_redundancy --first_file_score 0.0 $ARGV[0] ";
    foreach ( @partition ) {
        print CMD2 "$tmp_dir/$_.gff3 ";
    }
    print CMD2 "> $tmp_dir/$seq_id.gff3 2> $tmp_dir/$seq_id.GFF3_merging_and_removing_redundancy.log\n";
}
close CMD1; close CMD2;

# 对每个数据块的基因模型进行格式化
my $cmdString = "ParaFly -c $tmp_dir/command.GFF3Clear.list -CPU $cpu &> $tmp_dir/command.GFF3Clear.log";
system ($cmdString) == 0 or die "Failed to execute: $cmdString\n$!\n";
# 对每条序列的基因模型进行整合
my $cmdString = "ParaFly -c $tmp_dir/command.GFF3_merging_and_removing_redundancy.list -CPU $cpu &> $tmp_dir/command.GFF3_merging_and_removing_redundancy.log";
system ($cmdString) == 0 or die "Failed to execute: $cmdString\n$!\n";

# 将所有序列的基因模型结果进行合并，得到结果文件$tmp_dir/out.gff3
open OUT, ">", "$tmp_dir/out.gff3" or die "Can not create file $tmp_dir/out.gff3, $!";
foreach my $seq_id (sort keys %out_id) {
    open IN, "$tmp_dir/$seq_id.gff3" or die "Can not open file $tmp_dir/$seq_id.gff3, $!";
    print OUT <IN>;
    close IN;
}
close OUT;

# 格式化输出结果，对基因预测结果进行重新编号。
$cmdString = "$bin_path/GFF3Clear --genome $ARGV[0] --gene_prefix $gene_prefix $tmp_dir/out.gff3 ";
system ($cmdString) == 0 or die "Failed to execute: $cmdString\n$!\n";


sub get_partition {
    my ($length, $ss, $os) = @_;
    my @out;

    my $pos = 1;
    push @out, $pos;
    while (($pos + $ss - 1) < $length) {
        $pos = $pos + $ss - 1 - $os + 1;
        push @out, $pos;
    }

    return @out;
}
